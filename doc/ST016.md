18. **3.1 当前子任务上下文准备Agent (Current Subtask Context Preparer):**

根据我们之前制定的 `编码任务计划 v1.0 (CodingTaskPlan_v1.0)`，当前需要处理的第一个子任务是：

*   **子任务ID (Sub-task ID):** `ST016`
*   **描述 (Description):** "Implement the Project_Knowledge_Base_Manager_Service (PKBM_Service) core logic for file operations."
    *   *(中文解释：实现项目知识库管理服务 (PKBM_Service) 的核心文件操作逻辑。)*
*   **优先级 (Priority):** 1
*   **依赖 (Dependencies):** 无

为了确保后续的详细设计工作能够顺利进行，我将从项目知识库 (PKBM) 中收集与 `ST016` 相关的所有必要信息，包括：
1.  相关的用户故事及其验收标准。
2.  相关的架构设计部分（组件职责、接口定义等）。
3.  项目元数据（如技术栈、编码规范等）。
4.  由于这是一个新功能的实现，目前没有“现有的相关代码片段”。

这些信息将被整理成一个上下文包，供后续的详细设计Agent（例如，“3.3 数据模型详细设计Agent” 和 “3.4 类与函数逻辑设计Agent”）使用。

---

**上下文包生成过程:**

1.  **获取当前子任务:** `ST016` 已从 `CodingTaskPlan_v1.0` 确认。
2.  **从PKBM调取相关上下文:**
    *   **用户故事和验收标准:** 我将查找 `RequirementsSpecificationDocument_v1.0` 中与PKBM文件操作逻辑相关的用户故事和验收标准。主要是围绕US002。
    *   **架构设计部分:** 我将从 `HighLevelArchitectureDesignDocument_v1.0` 中提取 `Project_Knowledge_Base_Manager_Service` 组件的职责、以及与其文件操作相关的架构原则。
    *   **项目元数据:** 我将参考 `项目元数据 v1.0` 以获取技术栈（Python, File-based PKBM）和任何已定义的编码规范。
    *   **现有代码:** 此任务是新实现，因此无现有代码。

现在，我将生成这个上下文包。

---

**输出: 当前子任务的完整上下文包 (Current Subtask Context Package)**

```json
{
  "context_package_id": "CP_ST016_v1.0",
  "sub_task_id": "ST016",
  "sub_task_description": "Implement the Project_Knowledge_Base_Manager_Service (PKBM_Service) core logic for file operations.",
  "timestamp": "CURRENT_TIMESTAMP", // To be filled by PKBM upon storage
  "generated_by_agent": "3.1 Current Subtask Context Preparer",
  "target_detailed_design_agents": [
    "3.3 Data Model Detailed Design Agent",
    "3.4 Class & Function Logic Design Agent"
  ],
  "context_data": {
    "user_stories_and_acceptance_criteria": [
      {
        "user_story_id": "US002",
        "text": "As a: System, I want to: store any received document or structured information in a file-based Project Knowledge Base (PKBM) using predefined directory structures and naming conventions that include version (timestamp) and descriptive tags in the filename, So that: all agents have a consistent, versioned, and retrievable source of project artifacts.",
        "notes": "Core PKBM functionality (Agent 0.2). Covers QG5, QG6, QG7, Q0.2.1. Write access is serialized (QG8).",
        "acceptance_criteria": [
          {
            "ac_id": "US002_AC1",
            "description": "Verify correct storage of documents in PKBM with proper naming and versioning.",
            "gherkin": "Given an Agent has a document or structured information to store\nAnd the PKBM uses a predefined directory structure (QG9)\nWhen the '0.2 Project Knowledge Base Manager Agent' receives the information\nThen a file is created in the appropriate predefined directory\nAnd the filename includes a descriptive tag, a version (timestamp as per QG5), and the source agent ID (Q0.2.1)\nAnd the content of the file exactly matches the information provided for storage\nAnd this write operation is serialized (QG8)."
          },
          {
            "ac_id": "US002_AC2",
            "description": "Verify PKBM provides information retrieval based on filenames and partial content scanning.",
            "gherkin": "Given information is stored in PKBM with descriptive filenames (Q0.2.1)\nWhen an Agent requests information from PKBM using tags, keywords, or associations\nThen the PKBM (simulated by Agent scanning filenames/content - QG10) can locate and provide the relevant file(s) or their paths."
          },
          {
            "ac_id": "US002_AC3",
            "description": "Verify PKBM uses TXT as default format if not specified.",
            "gherkin": "Given an Agent provides information to PKBM without specifying a format\nAnd the information is not explicitly Markdown or JSON\nThen the PKBM stores the information as a plain TXT file (QG7)."
          }
        ]
      }
    ],
    "architecture_context": {
      "relevant_component_name": "Project_Knowledge_Base_Manager_Service (PKBM_Service)",
      "component_description_from_architecture_doc": "Manages all persistent storage and retrieval of project artifacts within the file-based system.",
      "core_responsibilities_from_architecture_doc": [
        "Providing an API for CRUD operations on artifacts (files)",
        "Enforcing directory structures and file naming conventions (including versioning and tags)",
        "Managing serialized write access",
        "Supporting artifact retrieval based on filenames/paths and simulated tag/keyword search"
      ],
      "key_architectural_principles_for_pkbm_core_logic": [
        "File-based storage (no traditional database).",
        "Operations must support a specific directory structure strategy (to be detailed by Data Model Design Agent).",
        "Operations must support file naming conventions including version (timestamp) and tags (to be detailed by Data Model Design Agent).",
        "All write operations to the file system must be strictly serialized to prevent race conditions (QG8 from US002_AC1)."
      ],
      "relevant_interfaces_to_be_supported_by_core_logic": [
        "Foundation for `store_artifact` (CID009 from ComponentInterfaceDraft_v1.0)",
        "Foundation for `retrieve_artifact` (CID010 from ComponentInterfaceDraft_v1.0)"
      ]
    },
    "project_metadata_context": {
      "source_document_id": "项目元数据 v1.0",
      "primary_programming_language": "Python",
      "project_knowledge_base_manager_pkbm": {
        "type": "File-based Knowledge Base",
        "organization": "Specific directory structure with individual files for each artifact.",
        "information_linking": "Through filename and directory structure conventions.",
        "write_management": "Strictly serialized writes to the knowledge base."
      },
      "coding_guidelines_source": "To be retrieved from PKBM. If not specified, follow standard Python (PEP 8) and project-specific conventions for AutoGen agent development. Focus on clarity, maintainability, and robust file operations. Ensure proper error handling for file I/O operations (e.g., file not found, permission issues, disk full)."
    },
    "existing_code_context": {
      "status": "Not applicable for this sub-task.",
      "reason": "ST016 is for the new implementation of PKBM_Service core logic."
    }
  }
}
```

19. **3.2 API详细设计Agent (API Detailed Design Agent):** *(如果子任务涉及API)*

1.  **子任务描述 (ST016):** 专注于实现 `PKBM_Service` 的 *核心文件操作逻辑*。
2.  **架构上下文:**
    *   `PKBM_Service` 的核心职责包括 "Providing an API for CRUD operations on artifacts (files)"。
    *   架构文档 (`HighLevelArchitectureDesignDocument_v1.0`，在“已完成阶段输出”中有提及) 第4节明确指出：“Agents within the `Agent_Orchestration_Service` interact with: `Project_Knowledge_Base_Manager_Service`: For storing and retrieving artifacts (e.g., `pkbm_service.store_artifact()`, `pkbm_service.retrieve_artifact()`) via **internal Python function calls**.”
    *   相关的接口草案ID (CID009 `store_artifact`, CID010 `retrieve_artifact`) 也在架构文档中被描述为 `PKBM_Service` 的内部调用。
3.  **目标详细设计Agent:** 上下文包 `CP_ST016_v1.0` 指向的目标Agent是 "3.3 Data Model Detailed Design Agent" 和 "3.4 Class & Function Logic Design Agent"。它并没有将本Agent (3.2 API详细设计Agent) 列为该子任务输出的主要消费者。

基于以上分析，我的结论是：

子任务 `ST016` 本身并不涉及创建或设计供外部 HTTP 调用的 API。`PKBM_Service` 的 "API" 在此上下文中指的是它向系统内其他Python组件（特别是其他Agent）暴露的内部编程接口（即Python类的方法和函数签名）。这些内部接口的详细设计将由后续的 **3.4 类与函数逻辑设计Agent** 负责。

因此，对于子任务 `ST016`，我不会生成一个包含 HTTP API 详细信息的文档。我将生成一份说明此评估的记录。

如果后续有其他子任务明确需要将 `PKBM_Service` 的功能通过 HTTP API 暴露给例如 `Web_UI_Service` 或其他外部系统，那么届时我才会为该特定子任务进行详细的 HTTP API 设计。

---

以下是我将存入PKBM的文档，标记为 **"API详细设计_ST016_v1.0"**:

```json
{
  "document_id": "APIDetailedDesign_ST016_v1.0",
  "sub_task_id": "ST016",
  "sub_task_description": "Implement the Project_Knowledge_Base_Manager_Service (PKBM_Service) core logic for file operations.",
  "version": "1.0",
  "timestamp": "CURRENT_TIMESTAMP", // To be filled by PKBM upon storage
  "generated_by_agent": "3.2 API Detailed Design Agent",
  "status": "Not Applicable",
  "reasoning": "Sub-task ST016 focuses on the core internal file operation logic for the PKBM_Service. As per the HighLevelArchitectureDesignDocument_v1.0 (Section 4) and the context package CP_ST016_v1.0, the PKBM_Service interacts with other internal system components (e.g., AutoGen agents) via internal Python function calls (e.g., pkbm_service.store_artifact(), pkbm_service.retrieve_artifact()), not external HTTP APIs. The detailed design of these internal Python interfaces (methods and function signatures) will be handled by the '3.4 Class & Function Logic Design Agent'. Therefore, no external HTTP API design is required for this specific sub-task.",
  "detailed_api_design": null,
  "next_recommended_agents_for_st016_output": [
    "3.3 Data Model Detailed Design Agent",
    "3.4 Class & Function Logic Design Agent"
  ]
}
```

20. **3.3 数据模型详细设计Agent (Data Model Detailed Design Agent):**

**Data Model Design Output:**

```json
{
  "document_id": "DataModelDetailedDesign_ST016_v1.0",
  "sub_task_id": "ST016",
  "sub_task_description": "Implement the Project_Knowledge_Base_Manager_Service (PKBM_Service) core logic for file operations.",
  "version": "1.0",
  "timestamp": "2023-10-29T10:00:00Z",
  "generated_by_agent": "3.3 Data Model Detailed Design Agent",
  "based_on_context_package": "CP_ST016_v1.0",
  "data_model_type": "File-Based System Organization",
  "design_details": {
    "pkbm_root_directory": {
      "description": "The base directory for the Project Knowledge Base. This should be configurable at the system level.",
      "example_placeholder": "/path/to/project_pkbm_root/"
    },
    "directory_structure_convention": {
      "description": "A two-level directory structure is proposed. The first level categorizes artifacts broadly. The second level (optional, if needed for further organization) can be based on a more specific artifact type or a unique project/session identifier if the PKBM needs to handle multiple distinct projects/sessions under one root (though current scope seems single-project focused). For ST016, we will focus on a primary category level.",
      "primary_categories": [
        {
          "category_name": "00_ProjectMetaData",
          "description": "Stores project-level metadata documents like '项目元数据 vX.Y'."
        },
        {
          "category_name": "01_RawRequirements",
          "description": "Stores raw user requirements, e.g., '原始用户需求 vX.Y'."
        },
        {
          "category_name": "02_IntentAnalysis",
          "description": "Stores outputs from intent recognition, e.g., '初步意图分析 vX.Y'."
        },
        {
          "category_name": "03_RequirementSpecifications",
          "description": "Stores detailed requirement specifications, user stories, acceptance criteria, e.g., '需求规格说明书 vX.Y', '用户故事集 vX.Y', '验收标准集 vX.Y'."
        },
        {
          "category_name": "04_ArchitectureDocuments",
          "description": "Stores architecture-related documents, e.g., '高层组件定义 vX.Y', '高层架构设计文档 vX.Y'."
        },
        {
          "category_name": "05_TaskDefinitions",
          "description": "Stores task breakdowns and plans, e.g., '编码子任务列表 vX.Y', '编码任务计划 vX.Y'."
        },
        {
          "category_name": "06_DetailedDesigns",
          "description": "Stores detailed design artifacts for sub-tasks, e.g., 'API详细设计_[子任务ID]_vX.Y', '实现指导书_[子任务ID]_vX.Y'."
        },
        {
          "category_name": "07_GeneratedCode",
          "description": "Stores code generated by LLMs or agents, including intermediate and final versions."
        },
        {
          "category_name": "08_TestArtifacts",
          "description": "Stores test cases, test results, and debugging reports."
        },
        {
          "category_name": "09_ReviewFeedback",
          "description": "Stores feedback from human review points."
        },
        {
          "category_name": "10_IntegrationLogs",
          "description": "Logs related to code integration."
        },
        {
          "category_name": "11_SystemLogsAndReports",
          "description": "General system operational logs, error reports, summary reports."
        },
        {
          "category_name": "99_Misc",
          "description": "For miscellaneous artifacts not fitting other categories."
        }
      ],
      "path_format": "[pkbm_root_directory]/[primary_category_name]/[filename]"
    },
    "file_naming_convention": {
      "description": "Filenames are designed to be descriptive and embed key metadata for identification, versioning, and retrieval, as per US002 and related Q&A.",
      "components": [
        {
          "name": "artifact_identifier",
          "description": "The primary name of the artifact, often including its conceptual version (e.g., '原始用户需求_v1.0', 'API详细设计_ST016_v1.0'). This should be unique enough within its context. For sub-task specific artifacts, it must include the sub_task_id.",
          "constraints": "Should not contain characters problematic for filenames. Spaces should be replaced with underscores."
        },
        {
          "name": "source_agent_id_tag",
          "description": "A tag indicating the agent that generated/owns this artifact (e.g., 'Agent0.1', 'Agent3.3'). This corresponds to Q0.2.1.",
          "format": "AgentX.Y (e.g., Agent0.1, Agent3.3)"
        },
        {
          "name": "timestamp_version",
          "description": "A precise timestamp acting as the physical file version, ensuring uniqueness and chronological ordering (YYYYMMDDHHMMSSmmm, as per QG5).",
          "format": "YYYYMMDDHHMMSSmmm"
        },
        {
          "name": "file_extension",
          "description": "Indicates the file type (e.g., .txt, .json, .md). Default is .txt if not specified (US002_AC3).",
          "supported": [".txt", ".json", ".md", ".py", ".java", ".html", ".css", ".js", ".puml", ".mer"]
        }
      ],
      "filename_format": "[artifact_identifier]-[source_agent_id_tag]-[timestamp_version].[file_extension]",
      "example_full_path": "/path/to/project_pkbm_root/01_RawRequirements/原始用户需求_v1.0-Agent0.1-20231026100000000.txt",
      "example_detailed_design_path": "/path/to/project_pkbm_root/06_DetailedDesigns/数据模型详细设计_ST016_v1.0-Agent3.3-20231029100000000.json"
    },
    "data_storage_format_details": {
      "default_format": ".txt (as per US002_AC3 if not specified and content is not intrinsically structured like JSON/MD)",
      "structured_data_formats": {
        "json": "Preferred for structured data, agent outputs, configurations.",
        "markdown": "Preferred for human-readable documents, reports, specifications."
      },
      "content_handling_note": "The PKBM_Service core logic (ST016) primarily deals with files as byte streams for storage and retrieval. Interpretation of content (e.g., parsing JSON) is generally the responsibility of the agent creating or consuming the artifact, though the PKBM service will use the file extension to correctly store the file."
    },
    "versioning_and_tagging_strategy": {
      "versioning": "Achieved via the 'timestamp_version' component in the filename. This ensures that every write operation can result in a new, uniquely identifiable file if needed, preserving history.",
      "tagging": "Implicitly handled by: \n1. The 'primary_category_name' in the directory structure.\n2. The 'artifact_identifier' in the filename.\n3. The 'source_agent_id_tag' in the filename.\nExplicit, more granular tagging (like a list of arbitrary tags) would require storage within the file content or a separate metadata file, which is beyond the scope of ST016's core file operations and current requirements for a simple file-based PKBM.",
      "information_linking": "Primarily through filename conventions (e.g., an artifact for sub-task 'STXYZ' will have 'STXYZ' in its name) and directory structure. Explicit links (e.g., 'document A refers to document B') would be stored within the content of artifacts if needed, or through specific knowledge graph features if the PKBM evolves (not in current scope)."
    },
    "write_serialization_note": {
      "description": "As per US002_AC1 (QG8) and Project Metadata, all write operations to the file system must be strictly serialized. The implementation of this (e.g., using file locks, a centralized queue for write operations within the PKBM_Service class) will be part of the '3.4 Class & Function Logic Design Agent's' task, but the data model (file system organization) must not inherently prevent this.",
      "impact_on_model": "No direct structural impact, but reinforces the need for well-defined file paths to avoid conflicts."
    }
  },
  "next_recommended_agent_for_ST016_output": "3.4 Class & Function Logic Design Agent"
}
```

21. **3.4 类与函数逻辑设计Agent (Class & Function Logic Design Agent):**

**Class & Function Logic Design Document Output:**

```json
{
  "document_id": "ClassFunctionLogicDesign_ST016_v1.0",
  "sub_task_id": "ST016",
  "sub_task_description": "Implement the Project_Knowledge_Base_Manager_Service (PKBM_Service) core logic for file operations.",
  "version": "1.0",
  "timestamp": "CURRENT_TIMESTAMP",
  "generated_by_agent": "3.4 Class & Function Logic Design Agent",
  "based_on_context_package": "CP_ST016_v1.0",
  "based_on_data_model_design": "DataModelDetailedDesign_ST016_v1.0",
  "design_details": {
    "classes": [
      {
        "class_name": "PKBMService",
        "description": "Manages all persistent storage and retrieval of project artifacts within a file-based system. It handles directory structure, file naming conventions, versioning via timestamps, and serialized write access.",
        "language": "Python",
        "attributes": [
          {
            "name": "root_dir",
            "type": "str",
            "description": "The absolute path to the root directory of the PKBM."
          },
          {
            "name": "primary_categories",
            "type": "List[str]",
            "description": "A list of valid primary category names, loaded from DataModelDetailedDesign_ST016_v1.0."
          },
          {
            "name": "write_lock",
            "type": "threading.Lock",
            "description": "A lock to ensure serialized write access to the file system, preventing race conditions."
          }
        ],
        "constructor": {
          "method_name": "__init__",
          "parameters": [
            {
              "name": "pkbm_root_directory",
              "type": "str",
              "description": "The root directory for the PKBM. Must be an absolute path."
            },
            {
              "name": "category_definitions",
              "type": "List[Dict[str, str]]",
              "description": "List of category definition objects (e.g., from DataModelDetailedDesign_ST016_v1.0 primary_categories)."
            }
          ],
          "return_type": "None",
          "core_logic": [
            "Initialize self.root_dir with pkbm_root_directory after validating it's an absolute path and exists (or can be created).",
            "Initialize self.primary_categories by extracting 'category_name' from each item in category_definitions.",
            "Initialize self.write_lock = threading.Lock().",
            "Call self._initialize_pkbm_structure() to ensure root and category directories exist."
          ],
          "error_handling": [
            "Raise ValueError if pkbm_root_directory is not an absolute path.",
            "Raise PKBMInitializationError if the root directory cannot be accessed or created."
          ]
        },
        "methods": [
          {
            "method_name": "_initialize_pkbm_structure",
            "visibility": "private",
            "parameters": [],
            "return_type": "None",
            "description": "Ensures the PKBM root directory and all defined primary category subdirectories exist.",
            "core_logic": [
              "Attempt to create self.root_dir if it doesn't exist (os.makedirs(self.root_dir, exist_ok=True)).",
              "For each category_name in self.primary_categories:",
              "  category_path = self._get_category_path(category_name).",
              "  Attempt to create category_path if it doesn't exist (os.makedirs(category_path, exist_ok=True))."
            ],
            "error_handling": [
              "Raise PKBMInitializationError if any directory creation fails due to permissions or other OS errors."
            ]
          },
          {
            "method_name": "_get_category_path",
            "visibility": "private",
            "parameters": [
              {"name": "category_name", "type": "str", "description": "The name of the primary category."}
            ],
            "return_type": "str",
            "description": "Constructs the full path to a given primary category directory.",
            "core_logic": [
              "If category_name not in self.primary_categories, raise InvalidCategoryError.",
              "Return os.path.join(self.root_dir, category_name)."
            ],
            "error_handling": [
              "Raise InvalidCategoryError if category_name is not a defined primary category."
            ]
          },
          {
            "method_name": "_generate_timestamp",
            "visibility": "private",
            "parameters": [],
            "return_type": "str",
            "description": "Generates a timestamp string in YYYYMMDDHHMMSSmmm format as per QG5.",
            "core_logic": [
              "Get current datetime: now = datetime.datetime.now().",
              "Format and return: now.strftime('%Y%m%d%H%M%S') + '{:03d}'.format(now.microsecond // 1000)."
            ]
          },
          {
            "method_name": "_generate_filename",
            "visibility": "private",
            "parameters": [
              {"name": "artifact_identifier", "type": "str", "description": "Primary identifier of the artifact."},
              {"name": "source_agent_id_tag", "type": "str", "description": "Tag for the source agent."},
              {"name": "timestamp_version", "type": "str", "description": "Generated timestamp for versioning."},
              {"name": "file_extension", "type": "str", "description": "File extension (e.g., 'txt', 'json')."}
            ],
            "return_type": "str",
            "description": "Constructs a filename based on the defined convention from DataModelDetailedDesign_ST016_v1.0.",
            "core_logic": [
              "Clean artifact_identifier (replace spaces with underscores, remove problematic characters).",
              "Return f\"{cleaned_artifact_identifier}-{source_agent_id_tag}-{timestamp_version}.{file_extension.lstrip('.')}\"."
            ]
          },
          {
            "method_name": "store_artifact",
            "visibility": "public",
            "parameters": [
              {"name": "category_name", "type": "str", "description": "The primary category for the artifact."},
              {"name": "artifact_identifier", "type": "str", "description": "The base identifier for the artifact (e.g., '需求规格说明书_v1.0')."},
              {"name": "source_agent_id", "type": "str", "description": "Identifier of the agent storing the artifact (e.g., 'Agent1.4')."},
              {"name": "content", "type": "Union[str, bytes]", "description": "The content to be stored."},
              {"name": "file_extension_override", "type": "Optional[str]", "default": "None", "description": "Explicitly set file extension. If None, attempts to infer or defaults to 'txt'."}
            ],
            "return_type": "str",
            "description": "Stores an artifact in the PKBM. Enforces naming conventions, versioning, and serialized writes. Implements US002_AC1, US002_AC3.",
            "core_logic": [
              "1. Validate category_name: if not in self.primary_categories, raise InvalidCategoryError.",
              "2. Determine file extension:",
              "   If file_extension_override is provided, use it (remove leading dot if present).",
              "   Else if content is bytes and artifact_identifier suggests a binary type (e.g. image based on its own extension), try to infer. (Simplified: for ST016, we might skip complex inference).",
              "   Else if artifact_identifier ends with '.json', '.md', use that.",
              "   Else, default to 'txt' (US002_AC3).",
              "3. Generate timestamp_version using self._generate_timestamp().",
              "4. Generate filename using self._generate_filename(artifact_identifier, source_agent_id, timestamp_version, determined_extension).",
              "5. Get target directory path: target_dir = self._get_category_path(category_name).",
              "6. Construct full file path: full_path = os.path.join(target_dir, filename).",
              "7. Acquire self.write_lock (with a timeout to prevent deadlocks, e.g., self.write_lock.acquire(timeout=10)). If lock not acquired, raise PKBMConcurrencyError.",
              "8. try:",
              "   Ensure target_dir exists: os.makedirs(target_dir, exist_ok=True). (Redundant if _initialize_pkbm_structure works, but good for safety).",
              "   Open file in write mode ('wb' if content is bytes, 'w' with encoding 'utf-8' if content is str).",
              "   Write content to file.",
              "   Close file.",
              "9. except Exception as e (e.g., IOError, OSError, PermissionError):",
              "   Log the error.",
              "   Raise PKBMStorageError(f\"Failed to store artifact {full_path}: {e}\").",
              "10. finally:",
              "    self.write_lock.release() if lock was acquired.",
              "11. Return full_path."
            ],
            "error_handling": [
              "InvalidCategoryError: If category_name is invalid.",
              "PKBMStorageError: For any file I/O errors during writing.",
              "PKBMConcurrencyError: If write lock cannot be acquired."
            ]
          },
          {
            "method_name": "retrieve_artifact_content",
            "visibility": "public",
            "parameters": [
              {"name": "full_artifact_path", "type": "str", "description": "The absolute path to the artifact file within the PKBM."},
              {"name": "as_bytes", "type": "bool", "default": "False", "description": "If True, returns content as bytes. Otherwise, attempts to decode as UTF-8 string."}
            ],
            "return_type": "Union[str, bytes, None]",
            "description": "Retrieves the content of a specific artifact given its full path. Returns None if not found.",
            "core_logic": [
              "1. Validate full_artifact_path starts with self.root_dir (security check). If not, log warning and return None or raise SecurityError.",
              "2. try:",
              "   Open file in read mode ('rb' if as_bytes, 'r' with encoding 'utf-8' otherwise).",
              "   Read content.",
              "   Close file.",
              "   Return content.",
              "3. except FileNotFoundError:",
              "   Return None.",
              "4. except Exception as e (e.g., IOError, OSError, PermissionError, UnicodeDecodeError):",
              "   Log the error.",
              "   Raise PKBMRetrievalError(f\"Failed to retrieve artifact {full_artifact_path}: {e}\")."
            ],
            "error_handling": [
              "PKBMRetrievalError: For file I/O or decoding errors.",
              "Returns None if file not found (as per description)."
            ]
          },
          {
            "method_name": "find_artifact_paths",
            "visibility": "public",
            "parameters": [
              {"name": "category_name", "type": "str", "description": "The primary category to search within."},
              {"name": "artifact_identifier_pattern", "type": "Optional[str]", "default":"None", "description": "A pattern to match against the artifact_identifier part of filenames (e.g., '需求规格说明书*', '*_v1.0*'). Simple glob-like matching or exact match if no wildcards."},
              {"name": "source_agent_id_pattern", "type": "Optional[str]", "default":"None", "description": "A pattern to match against the source_agent_id_tag."},
              {"name": "timestamp_range_start", "type": "Optional[str]", "default":"None", "description": "Timestamp (YYYYMMDDHHMMSSmmm) to filter artifacts created on or after this time."},
              {"name": "timestamp_range_end", "type": "Optional[str]", "default":"None", "description": "Timestamp (YYYYMMDDHHMMSSmmm) to filter artifacts created on or before this time."},
              {"name": "latest_only", "type": "bool", "default":"False", "description": "If True, returns only the path to the most recent matching artifact."}
            ],
            "return_type": "List[str]",
            "description": "Finds artifact paths within a category matching given criteria. Implements part of US002_AC2. 'Partial content scanning' is out of scope for ST016.",
            "core_logic": [
              "1. Validate category_name: if not in self.primary_categories, raise InvalidCategoryError; else get category_path = self._get_category_path(category_name).",
              "2. If not os.path.isdir(category_path), return [].",
              "3. Initialize empty list: matching_files = [].",
              "4. For each item_name in os.listdir(category_path):",
              "   item_path = os.path.join(category_path, item_name).",
              "   If os.path.isfile(item_path):",
              "     filename_parts = self._parse_filename(item_name) # Helper to parse name, agent, timestamp, ext",
              "     If filename_parts is None (not matching format), continue.",
              "     match = True",
              "     If artifact_identifier_pattern and not fnmatch.fnmatch(filename_parts['identifier'], artifact_identifier_pattern), match = False.",
              "     If source_agent_id_pattern and not fnmatch.fnmatch(filename_parts['agent_id'], source_agent_id_pattern), match = False.",
              "     If timestamp_range_start and filename_parts['timestamp'] < timestamp_range_start, match = False.",
              "     If timestamp_range_end and filename_parts['timestamp'] > timestamp_range_end, match = False.",
              "     If match, add (item_path, filename_parts['timestamp']) to a temporary list.",
              "5. Sort the temporary list by timestamp (descending if latest_only is True, or for consistent ordering).",
              "6. If latest_only and temporary list is not empty, matching_files = [temporary_list[0][0]].",
              "7. Else, matching_files = [path for path, ts in temporary_list].",
              "8. Return matching_files."
            ],
            "error_handling": [
              "InvalidCategoryError: If category_name is invalid."
            ]
          },
          {
            "method_name": "_parse_filename",
            "visibility": "private",
            "parameters": [
              {"name": "filename_with_ext", "type": "str", "description": "The full filename including extension."}
            ],
            "return_type": "Optional[Dict[str, str]]",
            "description": "Parses a filename to extract its components based on the defined convention. Returns None if format doesn't match.",
            "core_logic": [
              "Use regular expression to match `(identifier)-(agent_id)-(timestamp).(extension)`.",
              "Example regex: r'^(?P<identifier>.+)-(?P<agent_id>Agent\\d+\\.\\d+)-(?P<timestamp>\\d{17})\\.(?P<extension>[a-zA-Z0-9]+)$'",
              "If match, return a dict: {'identifier': ..., 'agent_id': ..., 'timestamp': ..., 'extension': ...}.",
              "Else, return None."
            ]
          }
        ],
        "custom_exceptions_needed": [
          "PKBMError(Exception): Base exception for PKBM service.",
          "PKBMInitializationError(PKBMError): For errors during PKBM setup.",
          "InvalidCategoryError(PKBMError): For invalid category names.",
          "PKBMStorageError(PKBMError): For errors during artifact storage.",
          "PKBMRetrievalError(PKBMError): For errors during artifact retrieval.",
          "PKBMConcurrencyError(PKBMError): For issues with acquiring write lock."
        ]
      }
    ],
    "general_design_considerations": [
      "Logging: All public methods and significant private methods should include logging (INFO for successful operations, WARNING for recoverable issues, ERROR/CRITICAL for failures). Use Python's `logging` module.",
      "Error Handling: Methods should clearly define exceptions they might raise. File I/O operations must be wrapped in try-except blocks.",
      "Atomicity: True atomicity for file writes is complex. The serialized write lock provides protection against concurrent writes by this service. For single file writes, OS operations are generally atomic at a low level, but power loss mid-write can still corrupt. This design assumes standard OS behavior.",
      "Configuration: The `pkbm_root_directory` and `category_definitions` are passed during instantiation, allowing flexibility.",
      "Dependencies: `os`, `datetime`, `threading`, `fnmatch` (for pattern matching), `re` (for parsing filename)."
    ]
  }
}
```

22. **3.5 文件与目录结构规划Agent (File & Directory Structure Planner Agent):**

**File & Directory Structure Plan Output:**

```json
{
  "document_id": "FileStructurePlan_ST016_v1.0",
  "sub_task_id": "ST016",
  "sub_task_description": "Implement the Project_Knowledge_Base_Manager_Service (PKBM_Service) core logic for file operations.",
  "version": "1.0",
  "timestamp": "CURRENT_TIMESTAMP",
  "generated_by_agent": "3.5 File & Directory Structure Planner Agent",
  "based_on_context_package": "CP_ST016_v1.0",
  "based_on_detailed_designs": [
    "DataModelDetailedDesign_ST016_v1.0",
    "ClassFunctionLogicDesign_ST016_v1.0"
  ],
  "project_structure_plan": {
    "comment": "This plan outlines the initial project source code structure focusing on ST016. The actual PKBM data storage (e.g., /path/to/project_pkbm_root/) is managed BY this service, not part of its source code structure.",
    "project_root_name": "MAS_Simplified_Project",
    "source_code_root_relative_to_project_root": "mas_core/",
    "new_directories_to_create": [
      {
        "path_relative_to_project_root": "mas_core/",
        "description": "Main source code directory for the Multi-Agent System."
      },
      {
        "path_relative_to_project_root": "mas_core/services/",
        "description": "Package for all core service components like PKBM, Workflow, LLM Gateway."
      },
      {
        "path_relative_to_project_root": "mas_core/utils/",
        "description": "Package for utility modules, including custom exceptions if they become general."
      }
    ],
    "new_files_to_create": [
      {
        "path_relative_to_project_root": "mas_core/__init__.py",
        "description": "Makes 'mas_core' a Python package."
      },
      {
        "path_relative_to_project_root": "mas_core/services/__init__.py",
        "description": "Makes 'services' a Python sub-package."
      },
      {
        "path_relative_to_project_root": "mas_core/utils/__init__.py",
        "description": "Makes 'utils' a Python sub-package."
      },
      {
        "path_relative_to_project_root": "mas_core/utils/custom_exceptions.py",
        "description": "File to store custom project-wide exceptions. PKBM-specific exceptions defined in ClassFunctionLogicDesign_ST016_v1.0 will initially reside here or directly in pkbm_service.py if not broadly reusable."
      },
      {
        "path_relative_to_project_root": "mas_core/services/pkbm_service.py",
        "description": "The Python module implementing the PKBMService class and its core logic as defined in ClassFunctionLogicDesign_ST016_v1.0 for sub-task ST016. PKBM-specific exceptions can also be defined here if not moved to custom_exceptions.py."
      }
    ],
    "existing_files_to_modify": [],
    "rationale_and_conventions": [
      "The structure follows common Python project organization practices.",
      "A top-level source directory `mas_core/` is used to encapsulate all primary application logic.",
      "`services/` sub-package groups different service components, promoting modularity as per HighLevelArchitectureDesignDocument_v1.0.",
      "Future services (Workflow_Management_Service, LLM_Interaction_Gateway_Service) would also reside as modules within `mas_core/services/`.",
      "Agent definitions (AutoGen based) would likely go into a `mas_core/agents/` package.",
      "Web UI (Flask) components would likely go into a `mas_core/web_ui/` package.",
      "`__init__.py` files are created to define Python packages, enabling proper imports.",
      "Custom exceptions are planned to be in `mas_core/utils/custom_exceptions.py` for better organization if they become reusable, or can be co-located if very specific. For ST016, the `PKBMError` hierarchy will be implemented within `pkbm_service.py` or `custom_exceptions.py` based on reusability assessment during coding."
    ],
    "pkbm_data_directory_note": "The directory structure defined in `DataModelDetailedDesign_ST016_v1.0` (e.g., `00_ProjectMetaData`, `01_RawRequirements`) refers to the internal organization of the *data managed by* the PKBMService. The root of this data structure (e.g., `/path/to/project_pkbm_root/`) will be a configuration parameter passed to the `PKBMService` class instance and is separate from the project's source code structure outlined here."
  }
}
```

23. **3.6 安全考量与检查点定义Agent (Security Considerations & Checkpoint Definer Agent):**

**Security Considerations & Checkpoint Definer Agent Output:**

```json
{
  "document_id": "SecurityConsiderations_ST016_v1.0",
  "sub_task_id": "ST016",
  "sub_task_description": "Implement the Project_Knowledge_Base_Manager_Service (PKBM_Service) core logic for file operations.",
  "version": "1.0",
  "timestamp": "CURRENT_TIMESTAMP",
  "generated_by_agent": "3.6 Security Considerations & Checkpoint Definer Agent",
  "based_on_context_package": "CP_ST016_v1.0",
  "based_on_detailed_designs": [
    "APIDetailedDesign_ST016_v1.0",
    "DataModelDetailedDesign_ST016_v1.0",
    "ClassFunctionLogicDesign_ST016_v1.0"
  ],
  "security_assessment": {
    "overall_security_posture_and_directives": {
      "summary": "The project operates under an explicit directive to prioritize functionality, simplicity, and operational success within an assumed 'absolutely secure environment'. Security measures that could introduce complexity or hinder ease of use are to be deprioritized or omitted. All permissions are considered fully open.",
      "source_of_directive": "User instruction during Agent 3.6 invocation."
    },
    "analysis_scope_for_st016": "The PKBM_Service core logic for file operations involves creating, reading, writing, and finding files within a defined directory structure. This inherently touches upon file system interactions.",
    "potential_risk_areas_considered_and_rationale_for_deprioritization": [
      {
        "risk_area": "Path Traversal / Arbitrary File Access",
        "standard_concern": "Maliciously crafted input (e.g., for category names, artifact identifiers) could lead to accessing files outside the intended PKBM root directory.",
        "project_specific_handling": "The `ClassFunctionLogicDesign_ST016_v1.0` for `PKBMService` includes: \n1. `_get_category_path`: Validates `category_name` against a predefined list. \n2. `retrieve_artifact_content`: Includes a basic check that `full_artifact_path` starts with `self.root_dir`. \nThese checks are primarily for correctness and robustness, aligning with the project's priorities. No *additional* complex security-specific path sanitization or validation layers are recommended due to the 'absolutely secure environment' and 'simplicity first' directives. The existing design for correctness sufficiently covers this for the stated operational context."
      },
      {
        "risk_area": "Insecure File Permissions",
        "standard_concern": "Files created might have overly permissive OS-level permissions, potentially allowing unauthorized access if the environment assumption was breached.",
        "project_specific_handling": "Per user directive, 'all permissions etc., should be fully open'. The system will rely on default OS file creation permissions. No specific umask settings or permission-modifying calls (e.g., `os.chmod`) will be implemented by the `PKBMService` to restrict permissions, as this would contradict the directive and potentially add complexity or cause operational failures in some environments if not configured correctly."
      },
      {
        "risk_area": "Data Exposure / Confidentiality",
        "standard_concern": "Artifacts stored in PKBM might contain sensitive information. Without encryption or access controls, this data is readable by anyone with file system access.",
        "project_specific_handling": "The 'absolutely secure environment' directive implies that file system access itself is controlled. Encryption at rest for PKBM artifacts is out of scope as it would add significant complexity. The system assumes that the environment handles the confidentiality of the PKBM data at the file system/OS level."
      },
      {
        "risk_area": "Denial of Service (DoS) via Resource Exhaustion",
        "standard_concern": "Large file uploads or numerous small file creations could exhaust disk space or inodes.",
        "project_specific_handling": "This is primarily an operational/capacity planning concern rather than a direct security vulnerability in the context of an internal tool. The `PKBMService` logic does not include specific quotas or size limits for artifacts, prioritizing simplicity. It's assumed the 'absolutely secure environment' implies trusted users who will not intentionally cause DoS, and operational monitoring would handle resource limits."
      },
      {
        "risk_area": "Race Conditions in File Operations",
        "standard_concern": "Concurrent writes to the same file or directory manipulations can lead to data corruption.",
        "project_specific_handling": "The `ClassFunctionLogicDesign_ST016_v1.0` specifies a `threading.Lock` (`write_lock`) within the `PKBMService` to serialize write operations (`store_artifact`). This is a robustness measure essential for data integrity and functionality, aligning with project priorities. No further complex distributed locking mechanisms are considered necessary."
      },
      {
        "risk_area": "Error Handling and Information Leakage",
        "standard_concern": "Verbose error messages could leak internal system details.",
        "project_specific_handling": "The `ClassFunctionLogicDesign_ST016_v1.0` proposes custom exceptions. Error messages should be logged comprehensively for debugging (internal use) but user-facing errors (if any propagate that far) should be managed by the UI layer. Prioritizing functionality and debuggability means detailed internal logging is preferred. Since the environment is 'absolutely secure', leakage of internal paths or error details in logs accessible only within this secure environment is not a primary concern."
      }
    ],
    "recommended_security_checkpoints_and_measures_for_st016_implementation": {
      "summary": "Given the explicit project directives, no additional security-specific checkpoints or complex hardening measures are recommended for ST016 beyond what is already incorporated for basic robustness and correctness in the `ClassFunctionLogicDesign_ST016_v1.0`.",
      "checkpoints_aligned_with_robustness_and_functionality": [
        {
          "id": "ST016_SEC_CP01",
          "description": "Ensure the implementation of `_get_category_path` strictly validates category names against the predefined list from `DataModelDetailedDesign_ST016_v1.0`.",
          "relevance": "Primarily for correctness and preventing accidental writes to incorrect locations. Satisfies basic path control."
        },
        {
          "id": "ST016_SEC_CP02",
          "description": "Ensure the `retrieve_artifact_content` method validates that the `full_artifact_path` parameter is within the configured `self.root_dir` before attempting file access.",
          "relevance": "Primarily for correctness and ensuring the service operates within its designated scope. Satisfies basic path control."
        },
        {
          "id": "ST016_SEC_CP03",
          "description": "Ensure the `write_lock` is correctly implemented and used in `store_artifact` to serialize write operations, preventing data corruption from concurrent internal calls.",
          "relevance": "Critical for data integrity and functional correctness."
        },
        {
          "id": "ST016_SEC_CP04",
          "description": "Implement robust error handling for all file I/O operations (e.g., using try-except blocks for `IOError`, `OSError`, `PermissionError`), logging errors appropriately for debugging.",
          "relevance": "Critical for functional stability and diagnosing issues. Detailed logs are acceptable within the assumed secure environment."
        }
      ],
      "measures_explicitly_omitted_due_to_project_directives": [
        "Complex input sanitization routines for filenames/paths beyond basic cleaning for filesystem compatibility.",
        "Implementation of specific file permission settings (e.g., `os.chmod`).",
        "Encryption of data at rest.",
        "Resource quotas or file size limitations within the `PKBMService` logic.",
        "Obfuscation of error messages intended for internal logs."
      ]
    },
    "key_takeaway_for_implementation_team": "Focus on implementing the `PKBMService` as per the `ClassFunctionLogicDesign_ST016_v1.0` with an emphasis on robust file operations, correct handling of paths as designed, and effective error logging. Assume the operating environment is secure and permissions are open. Do not introduce security measures that add complexity or could impede straightforward operation and configuration."
  }
}
```

24. **3.7 详细设计汇总与指令生成Agent (Detailed Design Aggregation & Instruction Generator Agent):**

This will be stored in PKBM as **`LLMPrompt_ST016_v1.0.txt`**.

```text
You are an expert Python programmer tasked with implementing a core service for a Multi-Agent System. Your goal is to create a robust and functional `PKBMService` class for managing a file-based Project Knowledge Base.

**IMPORTANT CONSTRAINTS AND DIRECTIVES:**
1.  **ABSOLUTELY NO SECURITY FEATURES:** The system will operate in an absolutely secure environment. All permissions are assumed to be fully open. Prioritize functional success and simplicity above all else. Do NOT implement any security measures (e.g., complex input sanitization beyond basic filesystem compatibility, file permission settings, encryption, resource quotas) that could add complexity or cause operational failures.
2.  **NO COMMENTS OR DOCSTRINGS:** The code must NOT contain any comments or docstrings.
3.  **CODING STANDARDS (Strictly Adhere):**
    *   Modular Design: Single responsibility for the class.
    *   Configuration Management: No hardcoding. Configuration (root directory, categories) injected via constructor. NO EXTERNAL CONFIG FILES.
    *   Error Handling: Use try-except for all I/O and potential errors. Raise custom exceptions as defined.
    *   Logging: Use the `logging` module. Logs must include timestamp, module name, level, function name, line number, and relevant trace info. Log execution time for key operations if applicable.
    *   Code Style: 4-space indent. Max 79 chars per line. ClassName: `CamelCase`. function_name, variable_name, method_name: `snake_case`. CONSTANT_NAME: `UPPER_SNAKE_CASE`. All names must be descriptive.
    *   Type Hints: MANDATORY for all function/method parameters and return values. Use `typing` module (e.g., `List`, `Dict`, `Optional`, `Union`).
    *   Dependencies: Prefer Python standard library.
    *   Code Reuse: Use private helper methods for repeated logic.

**TASK: Implement the `PKBMService` class in a new Python file.**

**FILE TO CREATE:** `MAS_Simplified_Project/mas_core/services/pkbm_service.py`

**REQUIRED IMPORTS:**
```python
import os
import datetime
import threading
import logging
import re
import fnmatch
from typing import List, Dict, Optional, Union, Any
```

**CUSTOM EXCEPTIONS TO DEFINE (within `pkbm_service.py`, before the class):**
```python
class PKBMError(Exception):
    pass

class PKBMInitializationError(PKBMError):
    pass

class InvalidCategoryError(PKBMError):
    pass

class PKBMStorageError(PKBMError):
    pass

class PKBMRetrievalError(PKBMError):
    pass

class PKBMConcurrencyError(PKBMError):
    pass
```

**CLASS DEFINITION: `PKBMService`**

**Attributes:**
*   `root_dir: str` (Absolute path to PKBM root)
*   `primary_categories: List[str]` (List of valid primary category names)
*   `write_lock: threading.Lock` (For serializing write access)

**Constructor:**
*   **Signature:** `def __init__(self, pkbm_root_directory: str, category_definitions: List[Dict[str, str]]) -> None:`
*   **Logic:**
    1.  Store `pkbm_root_directory` in `self.root_dir`. Validate it's an absolute path. If not, raise `ValueError("PKBM root directory must be an absolute path.")`.
    2.  Initialize `self.primary_categories` by extracting the 'category_name' string from each dictionary in the `category_definitions` list.
    3.  Initialize `self.write_lock = threading.Lock()`.
    4.  Call `self._initialize_pkbm_structure()`.
    5.  Handle potential `OSError` during directory checks/creation in `_initialize_pkbm_structure` by raising `PKBMInitializationError`.

**Private Methods:**

1.  **`_initialize_pkbm_structure(self) -> None:`**
    *   Logic:
        1.  Try to create `self.root_dir` if it doesn't exist: `os.makedirs(self.root_dir, exist_ok=True)`.
        2.  For each `category_name` in `self.primary_categories`:
            *   `category_path = os.path.join(self.root_dir, category_name)`.
            *   Try to create `category_path` if it doesn't exist: `os.makedirs(category_path, exist_ok=True)`.
    *   Error Handling: If any `os.makedirs` call fails (e.g., due to permissions), catch `OSError` and raise `PKBMInitializationError(f"Failed to create/access PKBM directory structure: {e}")`.

2.  **`_get_category_path(self, category_name: str) -> str:`**
    *   Logic:
        1.  If `category_name` is not in `self.primary_categories`, raise `InvalidCategoryError(f"Category '{category_name}' is not a defined primary category.")`.
        2.  Return `os.path.join(self.root_dir, category_name)`.

3.  **`_generate_timestamp(self) -> str:`**
    *   Logic:
        1.  `now = datetime.datetime.now()`.
        2.  Return `now.strftime('%Y%m%d%H%M%S') + '{:03d}'.format(now.microsecond // 1000)`.

4.  **`_generate_filename(self, artifact_identifier: str, source_agent_id_tag: str, timestamp_version: str, file_extension: str) -> str:`**
    *   Logic:
        1.  `cleaned_artifact_identifier = artifact_identifier.replace(' ', '_')` (Add more cleaning if necessary for filesystem compatibility, but keep it simple).
        2.  Return `f"{cleaned_artifact_identifier}-{source_agent_id_tag}-{timestamp_version}.{file_extension.lstrip('.')}"`.

5.  **`_parse_filename(self, filename_with_ext: str) -> Optional[Dict[str, str]]:`**
    *   Logic:
        1.  Define regex: `pattern = re.compile(r'^(?P<identifier>.+)-(?P<agent_id>Agent\d+\.\d+)-(?P<timestamp>\d{17})\.(?P<extension>[a-zA-Z0-9]+)$')`.
        2.  `match = pattern.match(filename_with_ext)`.
        3.  If `match`, return `match.groupdict()`.
        4.  Else, return `None`.

**Public Methods:**

1.  **`store_artifact(self, category_name: str, artifact_identifier: str, source_agent_id: str, content: Union[str, bytes], file_extension_override: Optional[str] = None) -> str:`**
    *   Logic:
        1.  `logger = logging.getLogger(__name__)`.
        2.  Call `self._get_category_path(category_name)` to get `target_dir`. (This will raise `InvalidCategoryError` if category is invalid).
        3.  Determine `determined_extension`:
            *   If `file_extension_override` is provided, use `file_extension_override.lstrip('.')`.
            *   Else if `artifact_identifier.lower().endswith('.json')`, use `'json'`.
            *   Else if `artifact_identifier.lower().endswith('.md')`, use `'md'`.
            *   Else, use `'txt'`.
        4.  `timestamp_version = self._generate_timestamp()`.
        5.  `filename = self._generate_filename(artifact_identifier, source_agent_id, timestamp_version, determined_extension)`.
        6.  `full_path = os.path.join(target_dir, filename)`.
        7.  `lock_acquired = self.write_lock.acquire(timeout=10)`.
        8.  If not `lock_acquired`, raise `PKBMConcurrencyError("Failed to acquire write lock for storing artifact.")`.
        9.  `try:`
            *   `os.makedirs(target_dir, exist_ok=True)` (for safety, though `_initialize_pkbm_structure` should handle it).
            *   If `isinstance(content, bytes)`: `mode = 'wb'`.
            *   Else (`isinstance(content, str)`): `mode = 'w'`, `encoding = 'utf-8'`.
            *   `with open(full_path, mode, encoding=(encoding if mode == 'w' else None)) as f:`
                *   `f.write(content)`.
            *   `logger.info(f"Artifact stored successfully: {full_path}")`.
            *   Return `full_path`.
        10. `except OSError as e:`
            *   `logger.error(f"OSError storing artifact {full_path}: {e}", exc_info=True)`.
            *   Raise `PKBMStorageError(f"Failed to store artifact {full_path}: {e}")`.
        11. `finally:`
            *   If `lock_acquired`, `self.write_lock.release()`.

2.  **`retrieve_artifact_content(self, full_artifact_path: str, as_bytes: bool = False) -> Union[str, bytes, None]:`**
    *   Logic:
        1.  `logger = logging.getLogger(__name__)`.
        2.  If not `full_artifact_path.startswith(os.path.abspath(self.root_dir))`:
            *   `logger.warning(f"Attempt to access path '{full_artifact_path}' outside of PKBM root '{self.root_dir}'.")`.
            *   Raise `PKBMRetrievalError("Attempt to access path outside of PKBM root.")` (For simplicity, raise error instead of returning None, as this is an invalid usage).
        3.  `try:`
            *   If `as_bytes`: `mode = 'rb'`, `encoding = None`.
            *   Else: `mode = 'r'`, `encoding = 'utf-8'`.
            *   `with open(full_artifact_path, mode, encoding=encoding) as f:`
                *   `content_data = f.read()`.
            *   `logger.info(f"Artifact content retrieved: {full_artifact_path}")`.
            *   Return `content_data`.
        4.  `except FileNotFoundError:`
            *   `logger.warning(f"Artifact not found: {full_artifact_path}")`.
            *   Return `None`.
        5.  `except OSError as e:`
            *   `logger.error(f"OSError retrieving artifact {full_artifact_path}: {e}", exc_info=True)`.
            *   Raise `PKBMRetrievalError(f"Failed to retrieve artifact {full_artifact_path} due to OS error: {e}")`.
        6.  `except UnicodeDecodeError as e:`
            *   `logger.error(f"UnicodeDecodeError retrieving artifact {full_artifact_path} as text: {e}", exc_info=True)`.
            *   Raise `PKBMRetrievalError(f"Failed to decode artifact {full_artifact_path} as text: {e}")`.

3.  **`find_artifact_paths(self, category_name: str, artifact_identifier_pattern: Optional[str] = None, source_agent_id_pattern: Optional[str] = None, timestamp_range_start: Optional[str] = None, timestamp_range_end: Optional[str] = None, latest_only: bool = False) -> List[str]:`**
    *   Logic:
        1.  `logger = logging.getLogger(__name__)`.
        2.  `category_path = self._get_category_path(category_name)`. (Raises `InvalidCategoryError` if invalid).
        3.  If not `os.path.isdir(category_path)`:
            *   `logger.warning(f"Category directory not found: {category_path}")`.
            *   Return `[]`.
        4.  `matching_files_with_ts: List[tuple[str, str]] = []`.
        5.  `try:`
            *   For `item_name` in `os.listdir(category_path)`:
                *   `item_path = os.path.join(category_path, item_name)`.
                *   If `os.path.isfile(item_path)`:
                    *   `filename_parts = self._parse_filename(item_name)`.
                    *   If `filename_parts` is `None`, continue.
                    *   `match = True`.
                    *   If `artifact_identifier_pattern` and not `fnmatch.fnmatch(filename_parts['identifier'], artifact_identifier_pattern)`, `match = False`.
                    *   If `source_agent_id_pattern` and not `fnmatch.fnmatch(filename_parts['agent_id'], source_agent_id_pattern)`, `match = False`.
                    *   If `timestamp_range_start` and `filename_parts['timestamp'] < timestamp_range_start`, `match = False`.
                    *   If `timestamp_range_end` and `filename_parts['timestamp'] > timestamp_range_end`, `match = False`.
                    *   If `match`, `matching_files_with_ts.append((item_path, filename_parts['timestamp']))`.
        6.  `except OSError as e:`
            *   `logger.error(f"OSError listing directory {category_path}: {e}", exc_info=True)`.
            *   Raise `PKBMRetrievalError(f"Failed to list artifacts in {category_path}: {e}")`.
        7.  Sort `matching_files_with_ts` by timestamp (second element of tuple) in descending order: `matching_files_with_ts.sort(key=lambda x: x[1], reverse=True)`.
        8.  If `latest_only` and `matching_files_with_ts`:
            *   `result = [matching_files_with_ts[0][0]]`.
        9.  Else:
            *   `result = [path for path, ts in matching_files_with_ts]`.
        10. `logger.info(f"Found {len(result)} artifact(s) matching criteria in category '{category_name}'.")`.
        11. Return `result`.

**DATA MODEL / NAMING CONVENTIONS (Context for implementation):**
*   PKBM Root Directory: Configurable, passed to constructor.
*   Directory Structure: `[pkbm_root_directory]/[primary_category_name]/[filename]`
*   Filename Format: `[artifact_identifier]-[source_agent_id_tag]-[timestamp_version].[file_extension]`
    *   `artifact_identifier`: e.g., '原始用户需求_v1.0'
    *   `source_agent_id_tag`: e.g., 'Agent0.1'
    *   `timestamp_version`: `YYYYMMDDHHMMSSmmm` (e.g., from `_generate_timestamp`)
    *   `file_extension`: e.g., 'txt', 'json', 'md'

**SECURITY CHECKPOINTS (Implement as part of robust logic, no extra security layers):**
*   **ST016_SEC_CP01:** `_get_category_path` must strictly validate `category_name` against `self.primary_categories`.
*   **ST016_SEC_CP02:** `retrieve_artifact_content` must validate `full_artifact_path` is within `self.root_dir`.
*   **ST016_SEC_CP03:** `write_lock` must be used correctly in `store_artifact` for serialized writes.
*   **ST016_SEC_CP04:** Robust error handling for all file I/O using try-except and custom exceptions, with appropriate logging.

**EXPECTED OUTPUT:**
A single, complete Python code file for `MAS_Simplified_Project/mas_core/services/pkbm_service.py`, containing the `PKBMService` class and its associated custom exceptions, adhering to all specified constraints and coding standards.
```
```

25. **3.8 人工审核点3协调Agent (Human Review Point 3 Coordinator):**

 ## 批准执行
