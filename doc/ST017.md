18. **3.1 当前子任务上下文准备Agent (Current Subtask Context Preparer):**

Based on our previous interactions and the provided documents, here is the context package for ST017:

```json
{
  "document_id": "SubTaskContextPackage_ST017_v1.0",
  "version": "1.0",
  "timestamp": "2023-10-29T11:00:00Z",
  "generated_by": "3.1 Current Subtask Context Preparer",
  "sub_task_id": "ST017",
  "sub_task_description": "Implement the `store_artifact` and `retrieve_artifact` interfaces in PKBM_Service. These are likely the methods previously designed as `store_artifact_content` and `retrieve_artifact_content` within the PKBMService class from ST016's design.",
  "relevant_user_stories": [
    {
      "user_story_id": "US002",
      "as_a": "System",
      "i_want_to": "store any received document or structured information in a file-based Project Knowledge Base (PKBM) using predefined directory structures and naming conventions that include version (timestamp) and descriptive tags in the filename",
      "so_that": "all agents have a consistent, versioned, and retrievable source of project artifacts.",
      "notes": "Core PKBM functionality (Agent 0.2). Covers QG5, QG6, QG7, Q0.2.1. Write access is serialized (QG8).",
      "acceptance_criteria": [
        {
          "ac_id": "US002_AC1",
          "description": "Verify correct storage of documents in PKBM with proper naming and versioning.",
          "gherkin": "Given an Agent has a document or structured information to store\nAnd the PKBM uses a predefined directory structure (QG9)\nWhen the '0.2 Project Knowledge Base Manager Agent' receives the information\nThen a file is created in the appropriate predefined directory\nAnd the filename includes a descriptive tag, a version (timestamp as per QG5), and the source agent ID (Q0.2.1)\nAnd the content of the file exactly matches the information provided for storage\nAnd this write operation is serialized (QG8)."
        },
        {
          "ac_id": "US002_AC2",
          "description": "Verify PKBM provides information retrieval based on filenames and partial content scanning.",
          "gherkin": "Given information is stored in PKBM with descriptive filenames (Q0.2.1)\nWhen an Agent requests information from PKBM using tags, keywords, or associations\nThen the PKBM (simulated by Agent scanning filenames/content - QG10) can locate and provide the relevant file(s) or their paths."
        }
      ]
    }
  ],
  "architecture_context": {
    "component_name": "Project_Knowledge_Base_Manager_Service (PKBM_Service)",
    "component_description": "Manages all persistent storage and retrieval of project artifacts within the file-based system.",
    "core_responsibilities_for_this_subtask": [
      "Implementing the primary public methods/interfaces for storing an artifact's content based on its metadata.",
      "Implementing the primary public methods/interfaces for retrieving an artifact's content based on its metadata.",
      "Ensuring these interface implementations leverage the core file operation logic, naming conventions, directory structure enforcement, and serialized write access established in ST016."
    ],
    "relevant_interfaces_overview": [
      "This sub-task focuses on implementing the specific Python methods within the `PKBMService` class that serve as the `store_artifact` and `retrieve_artifact` interfaces.",
      "These are the methods that other services (e.g., Agent_Orchestration_Service) will call to interact with the PKBM.",
      "The design for these methods was previously detailed in 'ClassFunctionLogicDesign_ST016_v1.0' as `store_artifact_content` and `retrieve_artifact_content`."
    ],
    "source_architecture_document_id": "HighLevelArchitectureDesignDocument_v1.0"
  },
  "project_metadata_context": {
    "project_name": "多Agent软件开发自动化系统 (简化版)",
    "primary_programming_language": "Python",
    "pkbm_specifics": {
      "type": "File-based Knowledge Base",
      "organization": "Specific directory structure with individual files for each artifact.",
      "information_linking": "Through filename and directory structure conventions.",
      "write_management": "Strictly serialized writes to the knowledge base.",
      "default_file_format": "TXT if not specified (e.g., for Markdown or JSON).",
      "versioning_scheme": "Timestamp in filename (as per QG5 from SRS)."
    },
    "source_project_metadata_document_id": "项目元数据 v1.0",
    "coding_standards": {
      "modular_design": {
        "single_responsibility": "Each class or module should focus on a single functionality, achieving high cohesion and low coupling.",
        "advanced_features": "Actively utilize Python's advanced features like decorators, classes, context managers, etc., to enhance code expressiveness and flexibility.",
        "plugin_architecture": "Consider a plugin-based or modular extension design for seamless future feature integration and expansion.",
        "clear_interfaces": "Modules interact through clearly defined and stable interfaces, reducing inter-module coupling.",
        "dependency_injection": {
          "usage": "Use Dependency Injection to manage inter-module dependencies.",
          "methods": "Inject dependencies via constructors, properties, or method parameters to reduce direct coupling.",
          "containers": "Consider using dependency injection containers or frameworks to simplify dependency management."
        },
        "event_driven_callbacks": {
          "usage": "For asynchronous tasks or scenarios requiring decoupling, adopt event-driven or callback mechanisms.",
          "interface_definition": "Define clear event and callback interfaces.",
          "event_bus": "Consider using an Event Bus or similar mechanism for loosely coupled communication between modules."
        }
      },
      "configuration_management": {
        "data_classes": "All configuration items MUST be managed via Python data classes, providing type safety and convenient access.",
        "centralized_definition": "All configuration items should be centrally defined in one or a few data classes, avoiding dispersion and duplication.",
        "no_hardcoding": "Strictly PROHIBIT hardcoding any configuration values in the code, ensuring configuration flexibility and maintainability.",
        "no_config_files": "PROHIBIT the use of any external configuration files (e.g., JSON, YAML); configuration is entirely borne by data classes.",
        "descriptive_naming": "Configuration item names should be highly descriptive, accurately reflecting their purpose and meaning, avoiding ambiguity."
      },
      "error_handling": {
        "comprehensive_capture": "Use try-except blocks to comprehensively capture and properly handle all possible exceptions, ensuring program robustness.",
        "clear_prompts": "Exception messages MUST include clear, accurate problem descriptions and use formatted output, highlighting key information for easy problem localization.",
        "avoid_crashes": "Ensure the program can gracefully handle or safely exit upon encountering exceptions, preventing crashes or data loss."
      },
      "logging": {
        "independent_log_files": "Use independent log files to record program operational status and key events, facilitating problem tracking and performance analysis.",
        "multi_level_logs": "Use different log levels (e.g., DEBUG, INFO, WARNING, ERROR, CRITICAL) to categorize event records for convenient filtering and viewing.",
        "detailed_information": "Each log message should include a timestamp, module name, log level, function name, line number, and other trace information helpful for problem localization.",
        "performance_tracking": "Record execution times of key operations or functions for performance analysis and optimization."
      },
      "code_style": {
        "indentation": "Uniformly use 4 spaces for code indentation, maintaining clear and consistent code structure.",
        "line_length": "Limit each line of code to 79 characters to improve readability.",
        "naming_conventions": {
          "class_names": "Use CamelCase.",
          "function_variable_method_names": "Use snake_case.",
          "constant_names": "Use UPPER_SNAKE_CASE (all uppercase letters, words separated by underscores).",
          "descriptiveness": "All names should be descriptive, avoiding abbreviations and ambiguous names, ensuring names accurately reflect their intended meaning."
        },
        "type_hints": "Use Type Hints to explicitly define function parameter and return value types, enhancing code readability, maintainability, and supporting static type checking."
      },
      "dependency_management": {
        "prefer_python_standard_library": "Prioritize using Python standard library and high-quality third-party libraries to implement functionality, reducing reliance on external tools.",
        "reduce_external_dependencies": "Minimize the use of shell commands or other external scripts to improve cross-platform compatibility and code portability."
      },
      "code_reuse": {
        "abstraction": "Abstract repetitive code logic into independent functions or methods to improve code reusability and maintainability.",
        "generality": "Ensure abstracted functions or methods have good generality, adaptable to different usage scenarios, avoiding rewriting similar code.",
        "encapsulation": "Encapsulate related variables and parameters into higher-level abstractions to simplify code structure."
      },
      "no_comments_policy": {
        "rule": "NO comments or DocStrings are allowed in the code. Code should be self-explanatory."
      }
    }
  },
  "existing_code_context": {
    "is_modification_task": true,
    "description": "This sub-task involves adding or completing the implementation of specific methods (`store_artifact_content`, `retrieve_artifact_content`) within the `PKBMService` class. This class and its associated data models (`PKBMConfig`, `ArtifactMetadata`) are defined as part of ST016.",
    "relevant_files_and_structures_from_st016_design": [
        {
            "file_path_from_project_root": "multi_agent_dev_system/pkbm_service/models.py",
            "contains": ["PKBMConfig (dataclass)", "ArtifactMetadata (dataclass)"]
        },
        {
            "file_path_from_project_root": "multi_agent_dev_system/pkbm_service/service.py",
            "contains": ["PKBMService (class)"],
            "modification_target": "The methods `store_artifact_content` and `retrieve_artifact_content` within the `PKBMService` class are the primary focus for implementation in ST017, based on their design in ST016's `ClassFunctionLogicDesign_ST016_v1.0`."
        }
    ],
    "code_snippets_or_paths": null,
    "file_structure_notes": "The file and directory structure for the `pkbm_service` package was defined in `FileStructurePlan_ST016_v1.0`. ST017 modifies files within this existing planned structure."
  },
  "dependent_subtask_designs": {
    "st016_data_model_design_id": "DataModelDetailedDesign_ST016_v1.0",
    "st016_class_function_logic_design_id": "ClassFunctionLogicDesign_ST016_v1.0"
  },
  "general_notes_for_detailed_design": [
    "ST017 is specifically about implementing the `store_artifact_content` and `retrieve_artifact_content` methods within the `PKBMService` class, as detailed in `ClassFunctionLogicDesign_ST016_v1.0`. The design provided for these methods in ST016's logic design document should be considered the primary specification.",
    "The implementation must utilize the `ArtifactMetadata` and `PKBMConfig` data models defined in `DataModelDetailedDesign_ST016_v1.0`.",
    "Ensure that these methods correctly handle parameters, return types, error conditions, and logging as specified in their design from ST016.",
    "The methods should make use of any helper methods (e.g., `_ensure_directory_exists`) and attributes (e.g., `_write_lock`, `_logger`) already designed for the `PKBMService` class in ST016.",
    "The 'no security' and 'no comments/docstrings' policies are paramount.",
    "Since ST016 was about the 'core logic for file operations' and ST017 is about 'implementing interfaces', it's confirmed that `store_artifact_content` and `retrieve_artifact_content` from the ST016 design are the exact methods to be fully implemented under ST017."
  ]
}
```

19. **3.2 API详细设计Agent (API Detailed Design Agent):**

**Conclusion for ST017:**

Sub-task ST017 is focused on the implementation of internal Python methods within the `PKBMService` class. These methods (`store_artifact_content` and `retrieve_artifact_content`, as designed in ST016's `ClassFunctionLogicDesign_ST016_v1.0`) constitute the *internal programming interface* for other Python-based services within the application.

This agent (3.2 API Detailed Design Agent) is responsible for designing *external* APIs (e.g., RESTful HTTP APIs). Since ST017 does not involve the creation or modification of any such external APIs for the `PKBM_Service` component, an API detailed design in the traditional sense (URLs, HTTP methods, request/response schemas for external communication) is **Not Applicable** for this sub-task.

The detailed design of the *Python method signatures and internal logic* for these interfaces was already covered in `ClassFunctionLogicDesign_ST016_v1.0` and will be the basis for the work in agent "3.4 类与函数逻辑设计Agent" if it were to re-evaluate or refine them for ST017 (though the context suggests ST017 is about implementing the ST016 design).

Therefore, my output will reflect this "Not Applicable" status.

Here is the formal output document:

```json
{
  "document_id": "APIDetailedDesign_ST017_v1.0",
  "version": "1.0",
  "timestamp": "2023-10-29T11:05:00Z",
  "generated_by": "3.2 API Detailed Design Agent",
  "sub_task_id": "ST017",
  "based_on_context_package": "SubTaskContextPackage_ST017_v1.0",
  "status": "Not Applicable",
  "reasoning": "Sub-task ST017 pertains to the implementation of internal Python methods (`store_artifact_content` and `retrieve_artifact_content`) within the `PKBMService` class. These methods serve as the internal programming interface for other Python components within the system, as clearly indicated by the sub-task description, architecture context (which specifies internal calls like CID009 and CID010), and the `HighLevelArchitectureDesignDocument_v1.0`. This agent (3.2 API Detailed Design Agent) is responsible for designing external APIs (e.g., RESTful HTTP services). Since no new or modified external APIs are required for the PKBM_Service component as part of ST017, a detailed external API design is not applicable. The design for the internal Python methods was covered in `ClassFunctionLogicDesign_ST016_v1.0`.",
  "api_designs": []
}
```


20. **3.3 数据模型详细设计Agent (Data Model Detailed Design Agent):**

I have received and reviewed the `SubTaskContextPackage_ST017_v1.0`. Let's analyze its implications for data modeling:

1.  **Sub-task Focus (ST017):** The core of ST017 is to "Implement the `store_artifact` and `retrieve_artifact` interfaces in PKBM_Service." The context package further clarifies these are the methods previously designed as `store_artifact_content` and `retrieve_artifact_content` within the `PKBMService` class, whose core logic was part of ST016.

2.  **Data Models from ST016:**
    *   The `SubTaskContextPackage_ST017_v1.0` explicitly states that ST017 will "utilize the `ArtifactMetadata` and `PKBMConfig` data models defined in `DataModelDetailedDesign_ST016_v1.0`."
    *   The `PKBMConfig` dataclass defines how the PKBM service is configured (e.g., root path, default directories, timestamp format).
    *   The `ArtifactMetadata` dataclass defines the structure for describing an artifact (e.g., base name, tag, source agent, version timestamp, extension, target subdirectory) and is crucial for generating filenames and paths.

3.  **Nature of `store_artifact_content` and `retrieve_artifact_content` methods:**
    *   The `store_artifact_content` method, as designed in `ClassFunctionLogicDesign_ST016_v1.0`, takes `metadata: ArtifactMetadata` and `content: Union[str, bytes]` as primary inputs.
    *   The `retrieve_artifact_content` method takes `metadata: ArtifactMetadata` as input and returns `Union[str, bytes]`.
    *   These methods operate on the *content* of artifacts, which is treated as an opaque `str` or `bytes` blob by these specific PKBM interface methods. The internal structure of this content is the concern of the agents producing or consuming it, not the PKBM service itself at this interface level.

4.  **Conclusion for ST017 Data Model Design:**
    *   **No new data models need to be designed for sub-task ST017.**
    *   The necessary data models (`PKBMConfig` and `ArtifactMetadata`) were already comprehensively designed and documented in `DataModelDetailedDesign_ST016_v1.0` as part of sub-task ST016.
    *   Sub-task ST017 is about implementing the *behavior* (methods) that *use* these existing data models. The inputs and outputs of these methods (`ArtifactMetadata`, `Union[str, bytes]`, `Path`) are defined by their signatures and rely on the pre-existing data model definitions.

Therefore, the output for this stage will state that no new data model design is required, and will reference the existing design document from ST016.

Here is the Data Model Detailed Design document for ST017:

```json
{
  "document_id": "DataModelDetailedDesign_ST017_v1.0",
  "version": "1.0",
  "timestamp": "2023-10-29T11:10:00Z",
  "generated_by": "3.3 Data Model Detailed Design Agent",
  "sub_task_id": "ST017",
  "based_on_context_package": "SubTaskContextPackage_ST017_v1.0",
  "design_sections": [
    {
      "title": "1. Introduction and Scope",
      "content_type": "structured_natural_language",
      "content": "This document addresses the data model design requirements for sub-task ST017: 'Implement the `store_artifact` and `retrieve_artifact` interfaces in PKBM_Service.' These interfaces correspond to the `store_artifact_content` and `retrieve_artifact_content` methods of the `PKBMService` class, whose detailed logic design was part of ST016."
    },
    {
      "title": "2. Assessment of Data Model Requirements for ST017",
      "content_type": "structured_natural_language",
      "content": [
        "The primary function of sub-task ST017 is the implementation of specific methods within the `PKBMService` class. These methods are responsible for storing and retrieving artifact content.",
        "The data structures required for these operations are:",
        "  - `PKBMConfig`: A Python dataclass for configuring the PKBM_Service (e.g., root path, naming conventions). This was fully defined in `DataModelDetailedDesign_ST016_v1.0`.",
        "  - `ArtifactMetadata`: A Python dataclass describing the artifact being processed (e.g., its name, tags, version, path components). This was also fully defined in `DataModelDetailedDesign_ST016_v1.0`.",
        "  - The artifact content itself, which is handled as `Union[str, bytes]` by these interface methods.",
        "The `store_artifact_content` and `retrieve_artifact_content` methods, as per their design in `ClassFunctionLogicDesign_ST016_v1.0`, use `ArtifactMetadata` as a key parameter and `PKBMConfig` (via `self.config` in the `PKBMService` instance) for their operations.",
        "No new conceptual data entities, database tables, file formats (for the PKBM's own operational data), or complex in-memory structures are introduced by the specific requirements of ST017 beyond what was established for ST016."
      ]
    },
    {
      "title": "3. Conclusion: No New Data Models Required",
      "content_type": "structured_natural_language",
      "content": [
        "Based on the analysis of `SubTaskContextPackage_ST017_v1.0` and the nature of sub-task ST017, it is determined that **no new data models need to be designed or existing ones updated for this sub-task.**",
        "The implementation of the `store_artifact_content` and `retrieve_artifact_content` interfaces will exclusively use the `PKBMConfig` and `ArtifactMetadata` Python dataclasses already defined in:",
        "  - **`DataModelDetailedDesign_ST016_v1.0`**",
        "These existing data models are sufficient and appropriate for the scope of ST017. The sub-task focuses on method implementation leveraging these pre-defined structures."
      ]
    }
  ]
}
```

21. **3.4 类与函数逻辑设计Agent (Class & Function Logic Design Agent):**

Here is the Class & Function Logic Design Document for ST017:

```json
{
  "document_id": "ClassFunctionLogicDesign_ST017_v1.0",
  "version": "1.0",
  "timestamp": "2023-10-29T11:15:00Z",
  "generated_by": "3.4 Class & Function Logic Design Agent",
  "sub_task_id": "ST017",
  "based_on_context_package": "SubTaskContextPackage_ST017_v1.0",
  "based_on_prior_designs": [
    "DataModelDetailedDesign_ST016_v1.0",
    "ClassFunctionLogicDesign_ST016_v1.0"
  ],
  "design_sections": [
    {
      "title": "1. Introduction and Scope",
      "content_type": "structured_natural_language",
      "content": [
        "This document outlines the class and function logic relevant to sub-task ST017: 'Implement the `store_artifact` and `retrieve_artifact` interfaces in PKBM_Service.'",
        "As per the `SubTaskContextPackage_ST017_v1.0`, these interfaces correspond directly to the methods `store_artifact_content` and `retrieve_artifact_content` within the `PKBMService` class.",
        "The comprehensive design for the `PKBMService` class, including the detailed logic for these specific methods, was already established in `ClassFunctionLogicDesign_ST016_v1.0`."
      ]
    },
    {
      "title": "2. Affected Class and Methods",
      "content_type": "structured_natural_language",
      "content": [
        "**Target Class:** `PKBMService` (defined in `pkbm_service/service.py`, as per `FileStructurePlan_ST016_v1.0`).",
        "**Target Methods for Implementation under ST017:**",
        "  1. `store_artifact_content(self, metadata: ArtifactMetadata, content: Union[str, bytes], overwrite: bool = False) -> Path`",
        "  2. `retrieve_artifact_content(self, metadata: ArtifactMetadata) -> Union[str, bytes]`"
      ]
    },
    {
      "title": "3. Reaffirmation of Existing Logic Design from ST016",
      "content_type": "structured_natural_language",
      "content": [
        "The detailed logic design for the methods `store_artifact_content` and `retrieve_artifact_content` is fully specified in the document: **`ClassFunctionLogicDesign_ST016_v1.0`**. Implementers of ST017 must refer to this document for:",
        "  - **`PKBMService.store_artifact_content`:** Refer to section '2. Core Service Class Design: PKBMService', method details under semantic anchor **`PKBMService_StoreArtifactContent`** in `ClassFunctionLogicDesign_ST016_v1.0`.",
        "  - **`PKBMService.retrieve_artifact_content`:** Refer to section '2. Core Service Class Design: PKBMService', method details under semantic anchor **`PKBMService_RetrieveArtifactContent`** in `ClassFunctionLogicDesign_ST016_v1.0`.",
        "This includes:",
        "  - Precise method signatures (name, parameters with types, return type).",
        "  - Detailed step-by-step core implementation logic (pseudocode).",
        "  - Error handling strategies and specific exceptions to catch and raise.",
        "  - Logging requirements (messages, levels).",
        "  - Usage of `PKBMConfig` and `ArtifactMetadata` data models.",
        "  - Interaction with `_write_lock` for `store_artifact_content`."
      ]
    },
    {
      "title": "4. Confirmation of Design Sufficiency for ST017",
      "content_type": "structured_natural_language",
      "content": [
        "The existing design for `store_artifact_content` and `retrieve_artifact_content` as provided in `ClassFunctionLogicDesign_ST016_v1.0` is confirmed to be complete, sufficient, and directly applicable for the implementation work required by sub-task ST017.",
        "No new classes or auxiliary functions need to be designed for ST017 beyond what is already defined within the `PKBMService` class structure from ST016."
      ]
    },
    {
      "title": "5. Key Implementation Considerations for ST017",
      "content_type": "structured_natural_language",
      "content": [
        "**Adherence to ST016 Design:** The implementation must strictly follow the logic, signatures, error handling, and logging specified in `ClassFunctionLogicDesign_ST016_v1.0` for the target methods.",
        "**Data Models:** Correctly utilize `ArtifactMetadata` and `PKBMConfig` (via `self.config`) as per their definitions in `DataModelDetailedDesign_ST016_v1.0`.",
        "**Coding Standards:** All project coding standards, including the 'no comments/docstrings' and 'no security specific code' policies, must be strictly observed during implementation.",
        "**Path Handling:** Use `pathlib.Path` for all filesystem path manipulations.",
        "**Helper Methods:** Leverage internal helper methods of `PKBMService` (e.g., `_ensure_directory_exists`, `_parse_filename_to_metadata` if indirectly used or for context) and attributes (`_write_lock`, `_logger`) as designed in ST016."
      ]
    },
    {
      "title": "6. Conclusion",
      "content_type": "structured_natural_language",
      "content": [
        "The class and function logic design task for ST017 primarily involves confirming and referencing the detailed design of the `store_artifact_content` and `retrieve_artifact_content` methods already provided in `ClassFunctionLogicDesign_ST016_v1.0`.",
        "No modifications to this existing design or creation of new class/function designs are required for ST017. The subsequent implementation phases should proceed based on these established specifications."
      ]
    }
  ]
}
```

22. **3.5 文件与目录结构规划Agent (File & Directory Structure Planner Agent):**


文件和目录结构变更计划如下:

```json
{
  "document_id": "FileStructurePlan_ST017_v1.0",
  "version": "1.0",
  "timestamp": "2023-10-29T11:20:00Z",
  "generated_by": "3.5 File & Directory Structure Planner Agent",
  "sub_task_id": "ST017",
  "based_on_documents": [
    "SubTaskContextPackage_ST017_v1.0",
    "APIDetailedDesign_ST017_v1.0 (Not Applicable)",
    "DataModelDetailedDesign_ST017_v1.0 (References ST016 design)",
    "ClassFunctionLogicDesign_ST017_v1.0 (References ST016 design)",
    "FileStructurePlan_ST016_v1.0 (Inferred)"
  ],
  "introduction": "This document outlines the file and directory structure changes for sub-task ST017. This sub-task involves implementing the `store_artifact` (as `store_artifact_content`) and `retrieve_artifact` (as `retrieve_artifact_content`) interfaces within the existing `PKBMService` class. The file structure was established by ST016.",
  "assumptions_and_conventions": [
    {
      "item": "Project Root for Source Code",
      "description": "The Python source code resides under 'multi_agent_dev_system/'."
    },
    {
      "item": "Existing Package Structure",
      "description": "The 'multi_agent_dev_system/pkbm_service/' package, including 'models.py' and 'service.py', is assumed to exist as planned in ST016."
    },
    {
      "item": "Modification Task",
      "description": "ST017 is a modification task, primarily affecting 'service.py' to implement methods within an existing class."
    }
  ],
  "file_structure_plan": [
    {
      "change_type": "NO_CHANGE_NEW_FILES",
      "full_path": null,
      "purpose": "No new files are required to be created for the core logic of sub-task ST017. The implementation will occur within existing files.",
      "directory_creation_needed": false
    },
    {
      "change_type": "NO_CHANGE_NEW_DIRECTORIES",
      "full_path": null,
      "purpose": "No new directories are required for sub-task ST017.",
      "directory_creation_needed": false
    },
    {
      "change_type": "MODIFY_EXISTING_FILE",
      "full_path": "multi_agent_dev_system/pkbm_service/service.py",
      "purpose": "This file contains the `PKBMService` class. It will be modified to fully implement the `store_artifact_content` and `retrieve_artifact_content` methods as per their detailed logic design provided in `ClassFunctionLogicDesign_ST016_v1.0` (and reaffirmed by `ClassFunctionLogicDesign_ST017_v1.0`).",
      "specific_changes_summary": [
        "Implement/complete the body of the `store_artifact_content` method.",
        "Implement/complete the body of the `retrieve_artifact_content` method."
      ]
    },
    {
      "change_type": "REFERENCE_EXISTING_FILE",
      "full_path": "multi_agent_dev_system/pkbm_service/models.py",
      "purpose": "This file contains the `PKBMConfig` and `ArtifactMetadata` dataclasses, which are essential inputs/outputs for the methods being implemented in 'service.py'. ST017 implementation will import and use these models, but the file 'models.py' itself is not expected to be changed by ST017.",
      "specific_changes_summary": ["No changes to this file by ST017."]
    },
    {
      "change_type": "REFERENCE_EXISTING_FILE",
      "full_path": "multi_agent_dev_system/pkbm_service/__init__.py",
      "purpose": "This file makes 'pkbm_service' a package and likely exports `PKBMService`, `PKBMConfig`, and `ArtifactMetadata`. It's referenced for package structure but not expected to be changed by ST017 unless ST016's plan for it was incomplete regarding exports (which is unlikely given standard practice).",
      "specific_changes_summary": ["No changes to this file anticipated by ST017."]
    }
  ],
  "notes_for_implementation": [
    "The primary focus of ST017 is code modification within 'multi_agent_dev_system/pkbm_service/service.py'.",
    "Ensure all imports from '.models' are correctly handled in 'service.py'.",
    "The structural integrity of the 'pkbm_service' package, as established by ST016, is maintained."
  ]
}
```

23. **3.6 安全考量与检查点定义Agent (Security Considerations & Checkpoint Definer Agent):**

Based on these, here is the Security Considerations Report for ST017.

```json
{
  "document_id": "SecurityConsiderations_ST017_v1.0",
  "version": "1.0",
  "timestamp": "2023-10-29T11:25:00Z",
  "generated_by": "3.6 Security Considerations & Checkpoint Definer Agent",
  "sub_task_id": "ST017",
  "based_on_documents": [
    "SubTaskContextPackage_ST017_v1.0",
    "APIDetailedDesign_ST017_v1.0",
    "DataModelDetailedDesign_ST017_v1.0",
    "ClassFunctionLogicDesign_ST017_v1.0",
    "SecurityConsiderations_ST016_v1.0"
  ],
  "sections": [
    {
      "title": "1. Overarching Security Policy and Its Impact on ST017",
      "content_type": "structured_natural_language",
      "content": [
        "**Project Directive Reiterated:** The project explicitly mandates operation within an 'absolutely secure environment'. All traditional security hardening, validation for security purposes, access control mechanisms (like keys or permission checks), and secret management are to be COMPLETELY IGNORED. The absolute priorities are functionality, success rate, and simplicity of use and configuration.",
        "**Impact on ST017 (PKBM Interface Implementation):** Sub-task ST017 involves implementing the `store_artifact_content` and `retrieve_artifact_content` methods within the `PKBMService` class. These methods directly interact with the filesystem based on provided `ArtifactMetadata`. Consistent with the project directive and the precedent set in `SecurityConsiderations_ST016_v1.0`, security concerns typically associated with such filesystem interactions are intentionally deprioritized.",
        "The focus for ST017 is the correct and robust *implementation* of the *functional logic* designed in ST016, not the introduction of security features."
      ]
    },
    {
      "title": "2. Analysis of Potential Risks (Conventionally Considered) for ST017 Methods",
      "content_type": "risk_analysis_list",
      "risks": [
        {
          "risk_id": "ST017-R001",
          "risk_name": "Path Traversal / Arbitrary File Access via `store_artifact_content` or `retrieve_artifact_content`",
          "description": "Conventionally, if the `ArtifactMetadata` input to these methods (specifically path-related components like `target_subdirectory`, `base_name`, `extension`) were manipulated, it could lead to writing to or reading from unintended locations outside the `PKBMConfig.root_path`.",
          "affected_methods": [
            "`PKBMService.store_artifact_content`",
            "`PKBMService.retrieve_artifact_content`"
          ],
          "project_specific_handling_due_to_policy": "This risk is **acknowledged but explicitly deprioritized** as per the project directive and `SecurityConsiderations_ST016_v1.0`. All `ArtifactMetadata` inputs are assumed to be trusted and benign. The design of `ArtifactMetadata.full_path` and `ArtifactMetadata.directory_path` (from ST016) inherently uses `PKBMConfig.root_path` as a base, providing structural organization, but this is not intended as a security measure against malicious inputs for ST017."
        },
        {
          "risk_id": "ST017-R002",
          "risk_name": "Data Integrity Issues from Incorrect Implementation",
          "description": "If the `store_artifact_content` method is not implemented correctly (e.g., issues with file modes, encodings, or handling of the `overwrite` flag), it could lead to corrupted or unintentionally overwritten data. If `retrieve_artifact_content` incorrectly determines binary vs. text, content could be misinterpreted.",
          "affected_methods": [
            "`PKBMService.store_artifact_content`",
            "`PKBMService.retrieve_artifact_content`"
          ],
          "project_specific_handling_due_to_policy": "This is a **functional robustness and data integrity concern**, which IS a priority. The detailed logic design in `ClassFunctionLogicDesign_ST016_v1.0` for these methods specifies correct handling of file modes, encodings, and the `overwrite` policy. Adherence to this design is critical for functionality."
        },
        {
          "risk_id": "ST017-R003",
          "risk_name": "Resource Exhaustion (DoS) via `store_artifact_content`",
          "description": "Conventionally, allowing the storage of excessively large files via `store_artifact_content` without checks could lead to disk space exhaustion.",
          "affected_methods": [
            "`PKBMService.store_artifact_content`"
          ],
          "project_specific_handling_due_to_policy": "This risk is **acknowledged but explicitly deprioritized** as per `SecurityConsiderations_ST016_v1.0`. No specific quotas or limits on file size will be implemented within this method. The 'absolutely secure environment' is assumed to manage system resources adequately."
        },
        {
          "risk_id": "ST017-R004",
          "risk_name": "Information Disclosure through Error Messages or Logging",
          "description": "Conventionally, detailed error messages or logs from these methods could reveal system information like full file paths.",
          "affected_methods": [
            "`PKBMService.store_artifact_content`",
            "`PKBMService.retrieve_artifact_content`"
          ],
          "project_specific_handling_due_to_policy": "The project's coding standards **prioritize detailed logging and informative error messages** for debuggability and operational transparency. This is considered acceptable and even desirable within the 'absolutely secure environment'. Potential information disclosure through these means is a deprioritized risk."
        }
      ]
    },
    {
      "title": "3. 'Security' Checkpoints and Recommendations for ST017 Implementation",
      "content_type": "checkpoint_list",
      "introduction": "Given the project's unique security policy, 'security checkpoints' for ST017 translate into 'functional correctness and adherence to design' checkpoints. The goal is to ensure the methods operate reliably and as intended, without introducing any security-specific code.",
      "checkpoints": [
        {
          "checkpoint_id": "ST017-CP001",
          "description": "**Strict Adherence to `ClassFunctionLogicDesign_ST016_v1.0`:** The implementation of `store_artifact_content` and `retrieve_artifact_content` MUST precisely follow the detailed logic, parameter handling, return types, error catching/raising, and logging specified in their respective sections within `ClassFunctionLogicDesign_ST016_v1.0` (semantic anchors `PKBMService_StoreArtifactContent` and `PKBMService_RetrieveArtifactContent`).",
          "implementation_guidance": "Verify every step of the pseudocode/logic from the ST016 design document. Ensure correct use of `self.config`, `self._write_lock` (for `store_artifact_content`), `self._logger`, and helper methods like `self._ensure_directory_exists`. Pay close attention to the logic for determining file open modes and encodings, and the handling of the `overwrite` flag.",
          "policy_relevance": "Ensures functional correctness and reliability, which are top priorities. Avoids introducing deviations that might break designed behavior or lead to data integrity issues."
        },
        {
          "checkpoint_id": "ST017-CP002",
          "description": "**Correct Usage of Data Models (`ArtifactMetadata`, `PKBMConfig`):** Ensure that the `ArtifactMetadata` objects are used correctly as inputs and that their properties (especially `full_path` and `directory_path`, which depend on `pkbm_config_ref`) are accessed as designed. The `PKBMConfig` (via `self.config`) must be the source for all configuration data (e.g., `root_path`, `filename_timestamp_format`).",
          "implementation_guidance": "The methods should expect `ArtifactMetadata` instances with `pkbm_config_ref` correctly pointing to `self.config`. The logic within these methods relies on this for correct path resolution and adherence to naming conventions.",
          "policy_relevance": "Critical for functional correctness. Incorrect use of these models will lead to files being stored in wrong locations, inability to retrieve files, or runtime errors."
        },
        {
          "checkpoint_id": "ST017-CP003",
          "description": "**Confirmation: No Introduction of Security-Specific Code:** The implementation of these methods MUST NOT introduce any new code for security validation (e.g., path sanitization, input filtering against malicious patterns, permission checks beyond basic OS errors). All inputs via `ArtifactMetadata` are trusted.",
          "implementation_guidance": "Focus solely on implementing the functional logic as designed. Do not add checks for '..' in paths, or try to restrict file types or sizes beyond what the existing design might imply for functional reasons (e.g., binary extension heuristic is for correct read mode, not security).",
          "policy_relevance": "Direct adherence to the project's 'no security considerations' and 'simplicity' directives. Avoids adding complexity or potential failure points related to unrequired security measures."
        },
        {
          "checkpoint_id": "ST017-CP004",
          "description": "**Robust Error Handling and Logging (Functional):** Implement all `try-except` blocks and logging calls precisely as specified in the `ClassFunctionLogicDesign_ST016_v1.0` for these methods. This is for operational robustness and debuggability, not security alerts.",
          "implementation_guidance": "Ensure specific exceptions (`FileNotFoundError`, `FileExistsError`, `ValueError`, `IOError`, `OSError`) are caught where designed, and that log messages are informative and use the correct levels.",
          "policy_relevance": "Supports high success rates and ease of problem diagnosis, aligning with project priorities."
        }
      ]
    },
    {
      "title": "4. Conclusion for ST017",
      "content_type": "structured_natural_language",
      "content": [
        "For sub-task ST017, the 'security' considerations are entirely superseded by the project's directive to prioritize functionality, simplicity, and operate within an assumed 'absolutely secure environment'.",
        "The focus of this report is therefore on ensuring that the implementation of `store_artifact_content` and `retrieve_artifact_content` strictly adheres to their pre-defined functional design (`ClassFunctionLogicDesign_ST016_v1.0`). This adherence is key to achieving the project's primary goals for these PKBM interface methods.",
        "No security-specific code, validation, or hardening should be added during the implementation of ST017."
      ]
    }
  ]
}
```

24. **3.7 详细设计汇总与指令生成Agent (Detailed Design Aggregation & Instruction Generator Agent):**

## 《代码实现指导书》(Implementation Guide) for Sub-task ST017

**Document ID:** ImplementationGuide_ST017_v1.0
**Version:** 1.0
**Timestamp:** (Will be set by PKBM upon storage)
**Generated By:** 3.7 Detailed Design Aggregation & Instruction Generator Agent
**Sub-task ID:** ST017
**Sub-task Description:** Implement the `store_artifact` and `retrieve_artifact` interfaces in PKBM_Service. These correspond to the methods `store_artifact_content` and `retrieve_artifact_content` within the `PKBMService` class, whose core logic and overall class structure were designed as part of ST016.

**Based On Documents:**
*   SubTaskContextPackage_ST017_v1.0
*   APIDetailedDesign_ST017_v1.0 (Status: Not Applicable)
*   DataModelDetailedDesign_ST017_v1.0 (Status: No new models, references ST016 design)
*   ClassFunctionLogicDesign_ST017_v1.0 (Status: Reaffirms ST016 design for `store_artifact_content` and `retrieve_artifact_content` methods)
*   FileStructurePlan_ST017_v1.0 (Status: Modifies existing file `multi_agent_dev_system/pkbm_service/service.py`)
*   SecurityConsiderations_ST017_v1.0 (Status: Reiterates "no security" policy, focuses on functional correctness based on ST016 design)
*   **Crucially, dependent designs from ST016:**
    *   `DataModelDetailedDesign_ST016_v1.0` (for PKBMConfig, ArtifactMetadata)
    *   `ClassFunctionLogicDesign_ST016_v1.0` (for the detailed logic of all PKBMService methods, including the target ones)
    *   `FileStructurePlan_ST016_v1.0` (for the initial structure of the `pkbm_service` package)

### 1. Introduction

This guide provides detailed instructions for implementing the `store_artifact_content` and `retrieve_artifact_content` methods within the existing `PKBMService` class, as part of the `Project_Knowledge_Base_Manager_Service`. This sub-task (ST017) focuses on realizing these specific public interfaces based on the comprehensive design established in ST016. The implementation must strictly adhere to the provided designs, project coding standards, and the overarching principle of prioritizing functionality and simplicity over security hardening.

### 2. General Implementation Notes

*   **Programming Language:** Python (as per `ProjectMetadata_v1.0`).
*   **No Security Implementation:** As per `SecurityConsiderations_ST017_v1.0` and `SubTaskContextPackage_ST017_v1.0`, all security considerations (input validation for security, authN/Z, secret management) are **explicitly excluded**. Assume a perfectly secure operating environment. The focus is on functional robustness and correctness.
*   **Coding Standards:** Strict adherence to the project's coding standards (provided in `SubTaskContextPackage_ST017_v1.0` and listed in the LLM prompt below) is mandatory. Key points include:
    *   Modular design (single responsibility).
    *   Configuration via Python dataclasses.
    *   Comprehensive error handling (try-except, clear messages, avoid crashes).
    *   Detailed logging.
    *   Code style (4-space indent, 79-char line limit, CamelCase for classes, snake_case for functions/variables, descriptive names).
    *   Type Hinting: Mandatory for all function parameters and return values.
    *   **Crucially: NO COMMENTS OR DOCSTRINGS. Code must be self-explanatory.**
*   **Path Handling:** Use `pathlib.Path` for all file system path manipulations.
*   **Error Handling & Logging:** Implement error handling and logging for the target methods *exactly* as specified in `ClassFunctionLogicDesign_ST016_v1.0`.
*   **Concurrency:** The `_write_lock` (`threading.Lock`) attribute of `PKBMService` must be used for `store_artifact_content` as designed.

### 3. File and Directory Structure

*   **Target File for Modification:** `multi_agent_dev_system/pkbm_service/service.py`
    *   This file, created as per `FileStructurePlan_ST016_v1.0`, contains the `PKBMService` class definition.
*   **Dependent Files (No Modification in ST017):**
    *   `multi_agent_dev_system/pkbm_service/models.py`: Contains `PKBMConfig` and `ArtifactMetadata` (defined in ST016).
    *   `multi_agent_dev_system/pkbm_service/__init__.py`: Makes `pkbm_service` a package (defined in ST016).

### 4. File Implementation Details for `multi_agent_dev_system/pkbm_service/service.py`

*   **Target Class:** `PKBMService`
*   **Target Methods for Implementation:**
    1.  **`store_artifact_content(self, metadata: ArtifactMetadata, content: Union[str, bytes], overwrite: bool = False) -> Path`**
        *   **Implementation Source:** The detailed logic, signature, error handling, and logging for this method are specified in `ClassFunctionLogicDesign_ST016_v1.0`, under the class `PKBMService`, method semantic anchor `PKBMService_StoreArtifactContent`. **This design must be implemented precisely.**
        *   Key aspects include: validating `metadata.pkbm_config_ref`, using `metadata.directory_path` and `metadata.full_path`, acquiring `_write_lock`, calling `_ensure_directory_exists`, handling the `overwrite` policy, determining file open mode and encoding, writing content, and appropriate logging/error handling.

    2.  **`retrieve_artifact_content(self, metadata: ArtifactMetadata) -> Union[str, bytes]`**
        *   **Implementation Source:** The detailed logic, signature, error handling, and logging for this method are specified in `ClassFunctionLogicDesign_ST016_v1.0`, under the class `PKBMService`, method semantic anchor `PKBMService_RetrieveArtifactContent`. **This design must be implemented precisely.**
        *   Key aspects include: validating `metadata.pkbm_config_ref`, using `metadata.full_path`, checking file existence, determining binary/text read mode based on extension heuristic, reading content, and appropriate logging/error handling.

*   **Contextual Class Structure:** The implementation of these methods will occur within the `PKBMService` class structure that includes other methods and attributes designed in ST016 (e.g., `__init__`, `_ensure_directory_exists`, `_write_lock`, `_logger`, `artifact_exists`, `delete_artifact`, `_parse_filename_to_metadata`, `list_artifacts`).

### 5. "Security" Checkpoints Review (Functional Correctness Focus)

As per `SecurityConsiderations_ST017_v1.0`, the following checkpoints (focused on functional correctness) must be met:
*   **ST017-CP001 (Strict Adherence to `ClassFunctionLogicDesign_ST016_v1.0`):** The implementation of the two target methods must precisely follow the ST016 design.
*   **ST017-CP002 (Correct Usage of Data Models):** `ArtifactMetadata` and `PKBMConfig` must be used as designed.
*   **ST017-CP003 (Confirmation: No Introduction of Security-Specific Code):** No security-specific validation or logic should be added.
*   **ST017-CP004 (Robust Error Handling and Logging - Functional):** Implement all `try-except` blocks and logging calls as specified in the ST016 design for these methods.

This guide, when followed, ensures that the implementation of `store_artifact_content` and `retrieve_artifact_content` methods meets all functional requirements for ST017 based on the established detailed designs from ST016.

---

Now, I will generate the **精确指令文本 (Prompt)** for the "Roo code LLM" for sub-task ST017.

```text
You are an expert Python developer tasked with modifying an existing Python file to implement specific methods within a class for a "多Agent软件开发自动化系统".
Your goal is to complete the implementation of two methods: `store_artifact_content` and `retrieve_artifact_content` within the `PKBMService` class in the file `multi_agent_dev_system/pkbm_service/service.py`.
The project operates in an **ABSOLUTELY SECURE ENVIRONMENT**. Therefore, ALL security considerations, including input validation for security, authentication, authorization, or secret management, MUST BE COMPLETELY IGNORED. Prioritize functionality, success rate, and simplicity of use.
No user interaction or CLI components are involved in this sub-task.

**CRITICAL CODING STANDARDS TO FOLLOW FOR ALL GENERATED CODE:**

1.  **MODULAR DESIGN:**
    *   Each class or module should focus on a single functionality (high cohesion, low coupling).
    *   Utilize Python's advanced features (decorators, classes, context managers) where appropriate.
    *   Modules should interact through clearly defined and stable interfaces.
    *   Use Dependency Injection principles where applicable (e.g., passing config objects).

2.  **CONFIGURATION MANAGEMENT:**
    *   All configuration items MUST be managed via Python dataclasses.
    *   All configuration items should be centrally defined.
    *   NO HARDCODING of configuration values.
    *   NO EXTERNAL CONFIGURATION FILES (JSON, YAML, etc.).
    *   Configuration item names should be descriptive.

3.  **ERROR HANDLING:**
    *   Use try-except blocks to comprehensively capture and properly handle all possible exceptions.
    *   Exception messages MUST include clear, accurate problem descriptions and use formatted output.
    *   Ensure the program can gracefully handle or safely propagate exceptions, avoiding crashes.

4.  **LOGGING:**
    *   Use the standard Python `logging` module.
    *   Log to independent log files (configuration of handlers is outside this scope, but assume a logger is provided or can be obtained via `logging.getLogger()`).
    *   Use different log levels (DEBUG, INFO, WARNING, ERROR, CRITICAL).
    *   Each log message should include timestamp, module name, log level, function name, line number, and trace information (achieved via logger configuration, but code should provide meaningful messages).
    *   Record execution times of key operations if specified in the design.

5.  **CODE STYLE:**
    *   Indentation: 4 spaces.
    *   Line Length: Max 79 characters.
    *   Naming Conventions:
        *   Class names: `CamelCase`.
        *   Function, variable, method names: `snake_case`.
        *   Constant names: `UPPER_SNAKE_CASE`.
        *   All names MUST be descriptive.
    *   Type Hints: MANDATORY for ALL function/method parameters and return values. Use the `typing` module.

6.  **DEPENDENCY MANAGEMENT:**
    *   Prioritize Python standard library.
    *   Minimize external (non-Python library) dependencies.

7.  **CODE REUSE:**
    *   Abstract repetitive logic into functions/methods.
    *   Ensure generality and encapsulation.

8.  **ABSOLUTELY NO COMMENTS OR DOCSTRINGS:**
    *   The code MUST be self-explanatory through clear naming, structure, and type hints.
    *   DO NOT ADD ANY `# comments` or `"""Docstrings"""` to the Python code.

**SUB-TASK ST017: Implement the `store_artifact` and `retrieve_artifact` interfaces in PKBM_Service.**
This means you will be implementing the methods `store_artifact_content` and `retrieve_artifact_content` within the `PKBMService` class.

**FILE TO MODIFY:** `multi_agent_dev_system/pkbm_service/service.py`

**CONTEXT - Data Models (from `multi_agent_dev_system/pkbm_service/models.py` - DO NOT REGENERATE THIS FILE, THIS IS FOR CONTEXT ONLY):**
```python
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, Optional, Any 
import datetime

@dataclass
class PKBMConfig:
    root_path: Path
    default_file_extension: str = '.txt'
    default_artifact_directories: Dict[str, str] = field(default_factory=lambda: {
        'unknown': '00_unknown',
        'initial_request': '01_initial_requests',
        'intent_analysis': '02_intent_analyses',
        'project_metadata': '03_project_metadata',
        'requirements_clarification': '04_requirements_clarifications',
        'user_stories': '05_user_stories',
        'acceptance_criteria': '06_acceptance_criteria',
        'requirements_specification': '07_requirements_specifications',
        'review_feedback': '08_review_feedback',
        'tech_selection': '09_tech_selections',
        'architecture_high_level': '10_architecture_high_level',
        'architecture_components': '10a_architecture_components',
        'architecture_interfaces': '10b_architecture_interfaces',
        'architecture_diagrams': '10c_architecture_diagrams',
        'coding_subtasks': '11_coding_subtasks',
        'coding_task_plan': '12_coding_task_plans',
        'subtask_context': '13_subtask_contexts',
        'detailed_design_api': '14_detailed_designs_api',
        'detailed_design_data_model': '14a_detailed_designs_data_model',
        'detailed_design_logic': '14b_detailed_designs_logic',
        'detailed_design_file_structure': '14c_detailed_designs_file_structure',
        'detailed_design_security': '14d_detailed_designs_security',
        'implementation_guide': '15_implementation_guides',
        'llm_prompt': '16_llm_prompts',
        'llm_output_raw': '17_llm_outputs_raw',
        'code_syntax_report': '18_code_syntax_reports',
        'code_formatted': '19_code_formatted',
        'static_analysis_report': '20_static_analysis_reports',
        'ai_code_review_report': '21_ai_code_review_reports',
        'code_human_reviewed': '22_code_human_reviewed',
        'unit_tests_code': '23_unit_tests_code',
        'unit_tests_results': '24_unit_tests_results',
        'debug_analysis_report': '25_debug_analysis_reports',
        'remediation_instruction': '26_remediation_instructions',
        'integration_log': '27_integration_logs',
        'build_log': '28_build_logs',
        'smoke_test_report': '29_smoke_test_reports',
        'code_with_comments': '30_code_with_comments',
        'updated_documentation': '31_updated_documentation',
        'final_acceptance_report': '32_final_acceptance_reports',
        'project_summary': '33_project_summaries',
        'knowledge_distillation': '34_knowledge_distillations',
        'error_log': '99_error_logs'
    })
    filename_timestamp_format: str = '%Y%m%d%H%M%S%f'

@dataclass
class ArtifactMetadata:
    base_name: str
    tag: str
    source_agent_id: str
    version_timestamp: datetime.datetime
    extension: str
    target_subdirectory: str
    content_type: Optional[str] = None
    pkbm_config_ref: Any = None # Represents PKBMConfig type

    @property
    def full_path(self) -> Path:
        if not self.pkbm_config_ref:
            raise ValueError('PKBMConfig reference is missing for full_path calculation.')
        timestamp_str = self.version_timestamp.strftime(self.pkbm_config_ref.filename_timestamp_format)
        filename = f"{self.base_name}_{self.tag}_{self.source_agent_id}_{timestamp_str}{self.extension}"
        return self.pkbm_config_ref.root_path / self.target_subdirectory / filename

    @property
    def directory_path(self) -> Path:
        if not self.pkbm_config_ref:
            raise ValueError('PKBMConfig reference is missing for directory_path calculation.')
        return self.pkbm_config_ref.root_path / self.target_subdirectory
```

**CONTEXT - Existing Structure of `PKBMService` class in `service.py` (Methods other than the target two are assumed to be already implemented or will be implemented in other sub-tasks. You only need to implement `store_artifact_content` and `retrieve_artifact_content` within this structure):**
```python
from pathlib import Path
from typing import Union, Optional, List, Dict, Any 
import datetime
import threading
import logging
import re

from .models import PKBMConfig, ArtifactMetadata

class PKBMService:
    def __init__(self, config: PKBMConfig) -> None:
        self.config: PKBMConfig = config
        self._write_lock: threading.Lock = threading.Lock()
        self._logger: logging.Logger = logging.getLogger('pkbm_service')
        self._logger.info(f'PKBMService initialized with root path: {self.config.root_path}')

    def _ensure_directory_exists(self, directory_path: Path) -> None:
        # This method is assumed to be implemented as per ST016 design.
        # For LLM context: it checks if directory_path exists, if not, acquires _write_lock, 
        # re-checks, then calls directory_path.mkdir(parents=True, exist_ok=True), logs, handles OSError.
        if not directory_path.exists():
            try:
                with self._write_lock:
                    if not directory_path.exists():
                        directory_path.mkdir(parents=True, exist_ok=True)
                        self._logger.info(f'Created directory: {directory_path}')
            except OSError as e:
                self._logger.error(f'Failed to create directory {directory_path}: {e}', exc_info=True)
                raise

    # Method to be implemented for ST017:
    def store_artifact_content(self, metadata: ArtifactMetadata, content: Union[str, bytes], overwrite: bool = False) -> Path:
        # <<< IMPLEMENT THIS METHOD BASED ON DETAILED LOGIC BELOW >>>
        pass

    # Method to be implemented for ST017:
    def retrieve_artifact_content(self, metadata: ArtifactMetadata) -> Union[str, bytes]:
        # <<< IMPLEMENT THIS METHOD BASED ON DETAILED LOGIC BELOW >>>
        pass

    def artifact_exists(self, metadata: ArtifactMetadata) -> bool:
        # This method is assumed to be implemented as per ST016 design.
        # For LLM context: it validates metadata.pkbm_config_ref, gets file_path, returns file_path.is_file().
        if metadata.pkbm_config_ref is not self.config:
            self._logger.error('ArtifactMetadata.pkbm_config_ref mismatch or not set during exists check.')
            raise ValueError('ArtifactMetadata.pkbm_config_ref must be set to the service config instance.')
        file_path: Path = metadata.full_path
        return file_path.is_file()

    def delete_artifact(self, metadata: ArtifactMetadata) -> bool:
        # This method is assumed to be implemented as per ST016 design.
        # For LLM context: it validates metadata.pkbm_config_ref, gets file_path, acquires _write_lock,
        # checks if file_path.is_file(), calls unlink(), logs, returns True/False, handles OSError.
        if metadata.pkbm_config_ref is not self.config:
            self._logger.error('ArtifactMetadata.pkbm_config_ref mismatch or not set during delete operation.')
            raise ValueError('ArtifactMetadata.pkbm_config_ref must be set to the service config instance.')
        file_path: Path = metadata.full_path
        deleted: bool = False
        try:
            with self._write_lock:
                if file_path.is_file():
                    file_path.unlink()
                    self._logger.info(f'Deleted artifact: {file_path}')
                    deleted = True
                else:
                    self._logger.warning(f'Artifact file not found for deletion: {file_path}')
                    deleted = False
        except OSError as e:
            self._logger.error(f'Failed to delete artifact {file_path}: {e}', exc_info=True)
            raise
        return deleted
        
    def _parse_filename_to_metadata(self, file_path: Path) -> Optional[ArtifactMetadata]:
        # This method is assumed to be implemented as per ST016 design.
        # For LLM context: it parses file_path.name to extract base_name, tag, source_agent_id, timestamp_str, extension.
        # Converts timestamp_str to datetime. Determines relative_subdirectory. Returns ArtifactMetadata or None.
        # Handles errors by logging and returning None.
        filename_stem: str = file_path.stem
        file_extension: str = file_path.suffix
        parts: List[str] = filename_stem.split('_')

        if len(parts) < 4:
            self._logger.debug(f'Filename {file_path.name} does not match expected parts for metadata parsing.')
            return None
        
        try:
            timestamp_str: str = parts[-1]
            source_agent_id: str = parts[-2]
            tag: str = parts[-3]
            base_name: str = '_'.join(parts[:-3])
            version_dt: datetime.datetime = datetime.datetime.strptime(timestamp_str, self.config.filename_timestamp_format)
            relative_subdirectory: str = str(file_path.parent.relative_to(self.config.root_path))
            
            return ArtifactMetadata(
                base_name=base_name,
                tag=tag,
                source_agent_id=source_agent_id,
                version_timestamp=version_dt,
                extension=file_extension,
                target_subdirectory=relative_subdirectory,
                pkbm_config_ref=self.config
            )
        except ValueError as e: # Catches strptime errors or relative_to errors if path not under root
            self._logger.debug(f'Failed to parse metadata components from filename {file_path.name}: {e}')
            return None
        except Exception as e: # Catch any other unexpected error during parsing
            self._logger.error(f'Unexpected error parsing filename {file_path.name}: {e}', exc_info=True)
            return None

    def list_artifacts(self, target_directory: Optional[str] = None, base_name_pattern: Optional[str] = None, tag_pattern: Optional[str] = None, agent_id_pattern: Optional[str] = None, content_keyword: Optional[str] = None) -> List[ArtifactMetadata]:
        # This method is assumed to be implemented as per ST016 design.
        # For LLM context: it determines search_root, compiles regex, iterates with rglob,
        # calls _parse_filename_to_metadata, applies filters, optionally searches .txt content,
        # appends to list, logs, returns list. Handles errors.
        search_root: Path
        if target_directory:
            search_root = self.config.root_path / target_directory
            if not search_root.is_dir():
                self._logger.warning(f'Target directory for listing artifacts does not exist: {search_root}')
                return []
        else:
            search_root = self.config.root_path

        found_artifacts: List[ArtifactMetadata] = []
        
        compiled_base_name_re = re.compile(base_name_pattern) if base_name_pattern else None
        compiled_tag_re = re.compile(tag_pattern) if tag_pattern else None
        compiled_agent_id_re = re.compile(agent_id_pattern) if agent_id_pattern else None

        try:
            for item_path in search_root.rglob('*'):
                if item_path.is_file():
                    metadata: Optional[ArtifactMetadata] = self._parse_filename_to_metadata(item_path)
                    if metadata:
                        matches_filters: bool = True
                        if compiled_base_name_re and not compiled_base_name_re.search(metadata.base_name):
                            matches_filters = False
                        if matches_filters and compiled_tag_re and not compiled_tag_re.search(metadata.tag):
                            matches_filters = False
                        if matches_filters and compiled_agent_id_re and not compiled_agent_id_re.search(metadata.source_agent_id):
                            matches_filters = False
                        
                        if matches_filters and content_keyword and metadata.extension.lower() == self.config.default_file_extension:
                            try:
                                with open(item_path, 'r', encoding='utf-8', errors='ignore') as f_content:
                                    file_content_text: str = f_content.read()
                                if content_keyword.lower() not in file_content_text.lower():
                                    matches_filters = False
                            except (IOError, OSError) as e_read:
                                self._logger.warning(f'Could not read file {item_path} for content search: {e_read}')
                                matches_filters = False
                        
                        if matches_filters:
                            found_artifacts.append(metadata)
        except Exception as e:
            self._logger.error(f'Error during artifact listing in {search_root}: {e}', exc_info=True)
            return [] # Return empty list on major failure during iteration

        self._logger.debug(f'Found {len(found_artifacts)} artifacts matching criteria in {search_root}.')
        return found_artifacts

```

**SPECIFIC INSTRUCTIONS FOR METHOD IMPLEMENTATION:**

1.  **Implement `store_artifact_content(self, metadata: ArtifactMetadata, content: Union[str, bytes], overwrite: bool = False) -> Path`:**
    *   **Semantic Anchor for Logic:** `PKBMService_StoreArtifactContent`
    *   **Detailed Logic to Implement (Must be followed PRECISELY):**
        1.  Validate `metadata.pkbm_config_ref`: If `metadata.pkbm_config_ref is not self.config`, log an `ERROR` message "ArtifactMetadata.pkbm_config_ref mismatch or not set during store operation." and `raise ValueError('ArtifactMetadata.pkbm_config_ref must be set to the service config instance.')`.
        2.  Determine `target_dir: Path = metadata.directory_path`.
        3.  Determine `file_path: Path = metadata.full_path`.
        4.  Acquire `self._write_lock` using a `with` statement.
        5.  Inside the lock:
            a.  Call `self._ensure_directory_exists(target_dir)`.
            b.  Check for file existence: If `file_path.exists() and not overwrite`:
                i.  Log `WARNING: Artifact file {file_path} already exists and overwrite is False.`
                ii. `raise FileExistsError(f'Artifact file {file_path} already exists. Set overwrite=True to replace.')`
            c.  Determine file open mode: `file_open_mode: str = 'wb' if isinstance(content, bytes) else 'w'`.
            d.  Determine file encoding: `file_encoding: Optional[str] = None if isinstance(content, bytes) else 'utf-8'`.
            e.  Open and write content: `with open(file_path, mode=file_open_mode, encoding=file_encoding) as f: f.write(content)`.
        6.  Log `INFO: Stored artifact: {file_path}`.
        7.  Return `file_path`.
        8.  Wrap the core logic (steps 1-7) in a `try` block. Catch `(IOError, OSError, ValueError, FileExistsError) as e`. In the `except` block, log `ERROR: Failed to store artifact at {metadata.full_path if metadata else 'unknown path'}: {e}` with `exc_info=True`, and then `raise e`.

2.  **Implement `retrieve_artifact_content(self, metadata: ArtifactMetadata) -> Union[str, bytes]`:**
    *   **Semantic Anchor for Logic:** `PKBMService_RetrieveArtifactContent`
    *   **Detailed Logic to Implement (Must be followed PRECISELY):**
        1.  Validate `metadata.pkbm_config_ref`: If `metadata.pkbm_config_ref is not self.config`, log an `ERROR` message "ArtifactMetadata.pkbm_config_ref mismatch or not set during retrieve operation." and `raise ValueError('ArtifactMetadata.pkbm_config_ref must be set to the service config instance.')`.
        2.  Determine `file_path: Path = metadata.full_path`.
        3.  Check file existence: If `not file_path.is_file()`:
            a.  Log `WARNING: Artifact file not found for retrieval: {file_path}`.
            b.  `raise FileNotFoundError(f'Artifact file not found: {file_path}')`.
        4.  Define `known_binary_extensions: List[str] = ['.gz', '.zip', '.tar', '.exe', '.dll', '.so', '.jar', '.class', '.pyc', '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.tiff', '.ico', '.pdf', '.doc', '.xls', '.ppt', '.docx', '.xlsx', '.pptx', '.odt', '.ods', '.odp', '.bin', '.dat', '.db']`.
        5.  Determine if binary: `is_binary: bool = metadata.extension.lower() in known_binary_extensions`.
        6.  Determine file open mode: `file_open_mode: str = 'rb' if is_binary else 'r'`.
        7.  Determine file encoding: `file_encoding: Optional[str] = None if is_binary else 'utf-8'`.
        8.  Read content: `with open(file_path, mode=file_open_mode, encoding=file_encoding) as f: content: Union[str, bytes] = f.read()`.
        9.  Log `DEBUG: Retrieved artifact: {file_path}`.
        10. Return `content`.
        11. Wrap the core logic (steps 1-10) in a `try` block. Catch `(IOError, OSError, FileNotFoundError, ValueError) as e`. In the `except` block, log `ERROR: Failed to retrieve artifact {metadata.full_path if metadata else 'unknown path'}: {e}` with `exc_info=True`, and then `raise e`.

**EXPECTED OUTPUT FORMAT:**
Provide ONLY the complete, modified Python code for the `multi_agent_dev_system/pkbm_service/service.py` file.
The output should be a single block of Python code representing the entire content of this file.
Do not include any explanatory text before or after the code block.
Ensure strict adherence to all coding standards, especially **NO COMMENTS OR DOCSTRINGS**.
The provided existing methods (`__init__`, `_ensure_directory_exists`, `artifact_exists`, `delete_artifact`, `_parse_filename_to_metadata`, `list_artifacts`) should remain in the class, and you should place your implementations of `store_artifact_content` and `retrieve_artifact_content` appropriately within the class structure (e.g., after `_ensure_directory_exists` and before `artifact_exists`).
```

